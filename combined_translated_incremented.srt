1
00:00:01,579 --> 00:00:04,420
欢迎来到编程入门。我叫 Steven，

2
00:00:04,420 --> 00:00:06,120
我叫 Sean。

3
00:00:06,120 --> 00:00:09,790
在接下来的 90 分钟内，我们将带您了解由 21 个不同部分

4
00:00:09,790 --> 00:00:13,599
组成的这个系列，希望涵盖计算机编程的基础知识

5
00:00:13,599 --> 00:00:17,600
可以应用于您可能想要学习的任何编程语言。我们将从最简单的问题开始，

6
00:00:17,600 --> 00:00:21,930
即什么是编程，然后从那里逐步讨论

7
00:00:21,930 --> 00:00:26,181
计算机科学的常见特性，例如循环和数组。我们将讨论

8
00:00:26,181 --> 00:00:30,859
如何读取和编写代码、调试您编写的代码、一些

9
00:00:30,859 --> 00:00:35,130
帮助规划代码的策略等等。屏幕上现在显示了此讲座

10
00:00:35,130 --> 00:00:39,549
式视频中将涵盖的完整主题列表。此外描述中会有时间戳，

11
00:00:39,549 --> 00:00:43,380
因此如果您已经精通计算机科学的某些领域，或者只是

12
00:00:43,380 --> 00:00:47,780
想了解我们将要涵盖的特定主题，请随意跳过。

13
00:00:47,780 --> 00:00:51,589
希望在本系列文章结束时，您能够对计算机科学有一个基本的了解，

14
00:00:51,589 --> 00:00:55,479
并掌握一系列有用的技能，帮助您解开

15
00:00:55,479 --> 00:00:58,159
您决定首先学习的任何编程语言。

16
00:00:58,159 --> 00:01:02,549
我们将仅介绍适用于所有编程语言的主要关键点，因此

17
00:01:02,549 --> 00:01:07,030
我们将避开面向对象编码（OOP）和命令行导航等主题，

18
00:01:07,030 --> 00:01:11,660
因为这些都是特定于语言的内容。此外，您无需下载任何软件

19
00:01:11,660 --> 00:01:15,670
以便跟随本教程，因为我们不会编写任何代码

20
00:01:15,670 --> 00:01:21,940
以使事情保持简单和集中。本视频适合对

21
00:01:21,940 --> 00:01:25,340
计算机科学感兴趣的人，但不知道从哪里开始

22
00:01:25,340 --> 00:01:29,720
也对编码背景知识知之甚少。如果这听起来像你，

23
00:01:29,720 --> 00:01:33,590
那么 Sean 和我将带您走进计算机科学的奇妙世界，首先回答您心中

24
00:01:33,590 --> 00:01:37,690
最大的问题，即编程到底是什么？

25
00:01:37,690 --> 00:01:43,450
好吧，字典中将其定义为准备设备教学程序的

26
00:01:43,450 --> 00:01:50,070
过程，但这个定义确实令人困惑，那么用外行人的话来说，这到底是

27
00:01:50,070 --> 00:01:55,909
什么意思？本质上，编程就是试图让计算机完成特定任务

28
00:01:55,909 --> 00:01:57,850
而不犯错误。

29
00:01:57,850 --> 00:02:05,650
举个例子，想象一下：你想让你不太聪明的朋友搭建一套乐高积木，但他丢失了

30
00:02:05,650 --> 00:02:11,560
说明书，只能按照你的命令搭建。但请记住，你的朋友

31
00:02:11,560 --> 00:02:16,250
远远不够熟练，所以如果没有给他非常具体的

32
00:02:16,250 --> 00:02:22,010
搭建说明，他可能会犯很多错误。如果他像计算机一样思考，

33
00:02:22,010 --> 00:02:25,730
那么只要你没有告诉他哪怕一块积木的具体摆放位置

34
00:02:25,730 --> 00:02:29,830
和摆放方法，整个乐高积木就会毁于一旦，

35
00:02:29,830 --> 00:02:35,281
他将彻底精神崩溃，导致整个项目目标被破坏。给你的

36
00:02:35,281 --> 00:02:41,450
朋友下达说明和程序员写代码的方式非常相似。你拥有的不是

37
00:02:41,450 --> 00:02:46,230
不太聪明的朋友，而是一台不太聪明的计算机，我们给它的不是

38
00:02:46,230 --> 00:02:50,840
乐高积木的搭建说明，而是如何完成游戏或网络应用程序

39
00:02:50,840 --> 00:02:56,890
等程序的信息。需要注意的一件重要事情是，计算机实际上非常笨。

40
00:02:56,890 --> 00:03:01,900
我们把它们打造成超级复杂的技术，但实际上，计算机

41
00:03:01,900 --> 00:03:05,739
的主要功能来自于我们如何操纵它来满足我们的需求。

42
00:03:05,739 --> 00:03:10,400
现在，编程并不像向朋友下达指令那么简单，因为对于程序员

43
00:03:10,400 --> 00:03:14,690
来说，计算机不会使用与您相同的语言，计算机只理解机器代码，

44
00:03:14,690 --> 00:03:19,450
这是一种称为二进制的数字语言，其设计目的是使

45
00:03:19,450 --> 00:03:24,150
计算机能够快速读取并执行其指令。输入计算机的

46
00:03:24,150 --> 00:03:29,110
每条指令都会转换为 1 和 0 的字符串，然后由

47
00:03:29,110 --> 00:03:32,070
计算机解释以执行任务。

48
00:03:32,070 --> 00:03:36,890
回到乐高的例子，这个过程就像他不仅不太聪明，

49
00:03:36,890 --> 00:03:43,740
而且更糟糕的是，他听不懂英语，只会说普通话。

50
00:03:43,740 --> 00:03:48,410
为了与他交谈，您必须将您理解的英语

51
00:03:48,410 --> 00:03:53,410
指令转换为您的朋友理解的语言。这个过程本质上就是

52
00:03:53,410 --> 00:03:57,940
你必须为你的计算机执行的操作，以便让它理解你给出的指令。

53
00:03:57,940 --> 00:04:02,320
然而，这两个例子之间的巨大区别在于，

54
00:04:02,320 --> 00:04:06,940
人们很难理解机器代码和二进制。将其转换成

55
00:04:06,940 --> 00:04:12,320
机器代码极其困难，实际上几乎不可能，而且

56
00:04:12,320 --> 00:04:17,850
即使可以实现也要花很长时间。每个程序都由数以百万计的

57
00:04:17,850 --> 00:04:22,949
1 和 0 组成，那么我们究竟该如何将指令转换成

58
00:04:22,949 --> 00:04:25,190
机器代码呢？

59
00:04:25,190 --> 00:04:29,819
这就是编程语言发挥作用的地方。编程语言从根本上

60
00:04:29,819 --> 00:04:34,990
来说是将程序转换成机器代码的中间人。这些语言比机器代码

61
00:04:34,990 --> 00:04:39,911
更容易让人学习，因此对程序员来说非常有用。回到

62
00:04:39,911 --> 00:04:44,919
我们的乐高例子，编程语言有点像解释器，能够

63
00:04:44,919 --> 00:04:48,849
接收你用英文给出的指令，并将其转换成你的

64
00:04:48,849 --> 00:04:53,860
非英语朋友可以理解的指令。这使得编程语言极其

65
00:04:53,860 --> 00:04:58,479
有用并且成为几乎所有优秀程序的支柱。编程语言

66
00:04:58,479 --> 00:05:03,210
既不是英语，也不是机器代码，而是介于两者之间。

67
00:05:03,210 --> 00:05:07,050
编程语言有很多种，每种语言都有自己独特的

68
00:05:07,050 --> 00:05:12,490
用途。Python，Java 等语言是通用语言，可以执行

69
00:05:12,490 --> 00:05:18,960
各种计算任务，而 RobotC 或 HTML/CSS 则是为更具体的用途

70
00:05:18,960 --> 00:05:24,169
而设计的语言，例如移动机器人或构建网站。语言的

71
00:05:24,169 --> 00:05:29,250
功能也各不相同。例如，JavaScript 是一种脚本语言，

72
00:05:29,250 --> 00:05:34,560
专为较小的任务而设计，而 Java 或 Python 可以执行计算量大得多

73
00:05:34,560 --> 00:05:35,560
的进程。

74
00:05:35,560 --> 00:05:41,110
我们通过编程语言与机器码（我们之前讨论过的一系列 0 和 1）

75
00:05:41,110 --> 00:05:46,229
的相似程度来衡量其能力或水平。汇编语言或 C 等

76
00:05:46,229 --> 00:05:51,400
低级编程语言比 Java 或 Python 等高级编程语言更

77
00:05:51,400 --> 00:05:53,509
接近二进制。

78
00:05:53,509 --> 00:05:58,199
基本思想是，编程语言的级别越低，代码就越像

79
00:05:58,199 --> 00:06:03,289
机器可以解释为指令的内容。除了每种语言实现

80
00:06:03,289 --> 00:06:07,310
的不同目的之外，选择编程语言通常取决于个人

81
00:06:07,310 --> 00:06:13,020
喜好，因为通常有许多语言可以完成类似的任务。

82
00:06:13,020 --> 00:06:17,940
尝试不同的语言，并决定您最喜欢哪种语言的规则、界面和

83
00:06:17,940 --> 00:06:20,750
简化程度。

84
00:06:20,750 --> 00:06:26,639
那么，既然我们知道了编程是什么，我们实际上如何编写代码呢？我们不能

85
00:06:26,639 --> 00:06:30,419
简单地在文本文档中键入单词，然后自动假设计算机可以

86
00:06:30,419 --> 00:06:35,229
将其转换为机器代码、读取它并执行诸如打开浏览器之类的任务。

87
00:06:35,229 --> 00:06:39,380
此外，我们不能仅仅用上一集提到的某些编程语言写下

88
00:06:39,380 --> 00:06:43,629
一堆废话，然后指望计算机能够理解。那么我们该如何编写

89
00:06:43,629 --> 00:06:44,629
代码呢？

90
00:06:44,629 --> 00:06:49,569
答案是使用 IDE。IDE 代表集成开发环境，

91
00:06:49,569 --> 00:06:54,159
它允许计算机编写代码。IDE 在您的计算机上提供了一个

92
00:06:54,159 --> 00:06:58,529
图形界面，程序员可以在其中轻松编写、运行和调试代码，

93
00:06:58,529 --> 00:07:03,110
而不必担心程序的编译或解释问题。可以将IDE 视为计算机

94
00:07:03,110 --> 00:07:07,189
上的任何其他程序，例如游戏、浏览器甚至文件资源管理器，

95
00:07:07,189 --> 00:07:11,619
只不过我们将使用它来编写代码。IDE 能够将您的代码转换为

96
00:07:11,619 --> 00:07:15,289
机器代码并通过计算机运行以产生结果。

97
00:07:15,289 --> 00:07:19,279
除了为程序员提供开发代码的地方之外，IDE 还为

98
00:07:19,279 --> 00:07:23,590
程序员提供了一些非常有用的工具来简化编写代码的工作，例如

99
00:07:23,590 --> 00:07:27,550
内置错误检查（因为我们稍后会讨论）；代码并不总是正确运行，

100
00:07:27,550 --> 00:07:31,909
自动填充常用单词或短语，以及项目层次结构，这将帮助

101
00:07:31,909 --> 00:07:36,539
您组织和操作项目中的文件。在过去，

102
00:07:36,539 --> 00:07:40,349
在 IDE 出现之前，代码曾经写在穿孔卡片上，然后输入计算机，

103
00:07:40,349 --> 00:07:45,569
这会花费数小时并带来很多麻烦。如今，IDE 已经成为一种编写代码的快速

104
00:07:45,569 --> 00:07:50,240
通道，让程序员的工作变得轻松很多。

105
00:07:50,240 --> 00:07:54,629
现在您可以在屏幕上看到特定 IDE 的示例。在中间，您可以看到

106
00:07:54,629 --> 00:07:58,679
当前正在编写的程序，在其正下方是控制台，它可以为程序员

107
00:07:58,679 --> 00:08:04,629
打印出有用的信息。这个特定的 IDE 用于编写 Java 代码。IDE 非常

108
00:08:04,629 --> 00:08:08,990
强大，几乎 100% 的编程项目都会用到它。

109
00:08:08,990 --> 00:08:12,789
因此，通过这些 IDE，我们终于能够顺利地编写和编译代码，

110
00:08:12,789 --> 00:08:16,719
而不必担心计算机无法理解它。接下来我们遇到的问题是，

111
00:08:16,719 --> 00:08:21,099
如何在 IDE 中编写这些代码，因为我们不能

112
00:08:21,099 --> 00:08:25,129
随便输入某种编程语言中的单词，然后期望编译器能够理解它。

113
00:08:25,129 --> 00:08:29,740
这就是编程语言语法发挥作用的地方。

114
00:08:29,740 --> 00:08:35,410
现在，就像学习一门真正的语言一样，学习计算机语言可能非常相似。

115
00:08:35,410 --> 00:08:40,150
有些语言风格各异，可能看起来很奇怪，有些语言可能会让你使用抽象或奇怪的概念，这可能会让人感

116
00:08:40,150 --> 00:08:44,700
到困惑，而且像所有语言一样，编程语言也有一套规则，

117
00:08:44,700 --> 00:08:48,400
在用该语言编写代码时必须遵循这些规则，而这些规则中最重要

118
00:08:48,400 --> 00:08:54,970
的是语法。编程语法被称为句法，与现实世界的语法非常相似。

119
00:08:54,970 --> 00:08:59,150
每种编程语言都有自己的语法或规则，如果你想让你的程序正确运行，

120
00:08:59,150 --> 00:09:04,720
你必须严格遵守这些规则，就像你在现实生活中说话一样。

121
00:09:04,720 --> 00:09:08,200
这些可以是诸如如何输入某些函数、在代码行末尾添加什么以

122
00:09:08,200 --> 00:09:13,590
及如何设置某些函数等内容。每种语言的语法都是独一无二的，

123
00:09:13,590 --> 00:09:18,120
虽然有些语言可能共享类似的规则，但所有语言都会有一些

124
00:09:18,120 --> 00:09:22,880
与众不同的怪癖。语法是让很多人措手不及的东西，因为许

125
00:09:22,880 --> 00:09:27,050
多人认为每种编程语言都遵循同一套规则，但正如我们

126
00:09:27,050 --> 00:09:31,700
在上一节中所说的那样，由于每种语言都专门用于特定任务，因此

127
00:09:31,700 --> 00:09:36,930
每种语言都需要自己的一套规则才能发挥作用。违反或无视这些规则将导致

128
00:09:36,930 --> 00:09:41,840
错误，就像在现实生活中违反或无视规则会导致意外

129
00:09:41,840 --> 00:09:43,160
消息一样。

130
00:09:43,160 --> 00:09:47,140
举个例子。如果我们想做一些简单的事情，比如初始化一个变量，

131
00:09:47,140 --> 00:09:51,620
这是我们还没有涉及的事情，但这个例子仍然相关。在 Java 中，

132
00:09:51,620 --> 00:09:56,410
你会注意到我们必须指定我们在本例中定义的变量类型，即整数，

133
00:09:56,410 --> 00:10:00,650
并在语句后添加分号。在 Python 中，我们甚至不需要定义

134
00:10:00,650 --> 00:10:05,360
我们正在尝试创建一个变量，只需输入我们想要创建的内容，

135
00:10:05,360 --> 00:10:09,271
而在 javascript 中，我们只需指定我们正在创建一个变量，但不包含我们

136
00:10:09,271 --> 00:10:15,270
想要创建的变量的类型。即使在这个简单的例子中，您也可以看到

137
00:10:15,270 --> 00:10:19,070
语法在学习一门新语言时有多重要，因为虽然我们程序的目标保持

138
00:10:19,070 --> 00:10:25,480
不变，即定义一个值为 3 的整数，但所示的所有编程语言都采用了不同的

139
00:10:25,480 --> 00:10:30,240
方法。所有这些语言都要求您遵循此语法，因为请记住，

140
00:10:30,240 --> 00:10:35,520
计算机非常笨，如果您忘记了一个分号或放错了一个字符，整个程序

141
00:10:35,520 --> 00:10:40,240
将无法运行并向您返回语法错误，这是我们稍后将讨论的内容。

142
00:10:40,240 --> 00:10:43,810
想象一下，如果你忘记了句子中的一个逗号，

143
00:10:43,810 --> 00:10:49,060
你想要表达的整个上下文就会被误解。例如，在 “我们吃，奶奶”

144
00:10:49,060 --> 00:10:53,070
这个句子中。如果你忘记了那个逗号，虽然这看起来像是一个小错误，

145
00:10:53,070 --> 00:10:56,460
但它会改变整个句子的上下文，听起来就像你要

146
00:10:56,460 --> 00:11:02,320
吃掉你的奶奶。编程也遵循同样的规则，如果你忘记了

147
00:11:02,320 --> 00:11:06,950
一个分号，你的程序的整个上下文可能会被破坏和误解。

148
00:11:06,950 --> 00:11:10,810
现在，IDE 的另一个用处是，它们会告知您代码中

149
00:11:10,810 --> 00:11:15,260
是否存在语法错误。语法错误当然是指代码中

150
00:11:15,260 --> 00:11:20,310
不遵循我们之前讨论过的规则的部分。IDE会告诉您

151
00:11:20,310 --> 00:11:24,600
代码中的错误位置，并且在错误修复之前不允许您运行

152
00:11:24,600 --> 00:11:29,110
程序。由于语法对于编写代码和学习新语言非常重要，

153
00:11:29,110 --> 00:11:32,600
因此建议您在开始用该语言编写复杂程序之前先学习

154
00:11:32,600 --> 00:11:37,450
该语言的规则和语法。大多数规则学起来很乏味，但

155
00:11:37,450 --> 00:11:41,290
易于掌握，一旦你能做到这一点，你就能够轻松识别

156
00:11:41,290 --> 00:11:45,330
语法错误并轻松处理它们。

157
00:11:45,330 --> 00:11:49,530
以上内容涵盖了语法和编程规则的基本要点，现在我们已经知道了如何编写代码

158
00:11:49,530 --> 00:11:53,590
以及在哪里编写代码，接下来我们需要介绍在输入程序并运行代码后

159
00:11:53,590 --> 00:11:57,370
会发生什么。因为为游戏或数据库编写一段代码很酷，

160
00:11:57,370 --> 00:12:01,500
但是在计算机解释程序后，我们如何知道发生了什么，

161
00:12:01,500 --> 00:12:06,290
以及它是否正常工作？好吧，程序员通过查看控制台来做到这一点。控制台

162
00:12:06,290 --> 00:12:10,320
是计算机内的文本界面，我们程序员可以将其用于各种不同的

163
00:12:10,320 --> 00:12:15,881
目的。如果您还记得，不久前我们展示了一张基本 IDE 

164
00:12:15,881 --> 00:12:18,800
的图片，该图片的主要部分之一就是控制台。

165
00:12:18,800 --> 00:12:23,690
控制台的主要用途是从程序中输出文本。这通常使用

166
00:12:23,690 --> 00:12:27,540
print 语句来完成。print 语句是一个命令，其作用正如其名称所示：

167
00:12:27,540 --> 00:12:31,380
它将文本打印到控制台。语句是我们在本系列中讨论的

168
00:12:31,380 --> 00:12:35,540
第一段实际代码，它非常简单。print 语句

169
00:12:35,540 --> 00:12:39,160
虽然简单，但却是编程中最重要的功能之一，

170
00:12:39,160 --> 00:12:41,920
几乎每种编程语言都以某种形式存在。

171
00:12:41,920 --> 00:12:46,600
您可以要求打印语句执行的最基本操作就是让它

172
00:12:46,600 --> 00:12:50,420
说些什么。这是通过指示控制台打印，然后将

173
00:12:50,420 --> 00:12:55,170
要打印的内容包含在括号内来完成的。例如，在 Python 中，代码段 

174
00:12:55,170 --> 00:13:00,070
print(“Hello World”) 会导致控制台上出现一条消息“hello world”。

175
00:13:00,070 --> 00:13:01,880
非常简洁。

176
00:13:01,880 --> 00:13:05,770
print 语句对于查看和解释程序的计算机输出也至关重要。

177
00:13:05,770 --> 00:13:11,070
例如，如果你告诉计算机运行一个简单的计算，

178
00:13:11,070 --> 00:13:16,270
例如确定 4+3 等于多少，它将在内部运行该程序并计算答案。

179
00:13:16,270 --> 00:13:19,080
但是，如果您无法知道结果是什么，那么让计算机运行这个程序的

180
00:13:19,080 --> 00:13:22,560
目的是什么呢？不要简单地告诉计算机执行此计算，

181
00:13:22,560 --> 00:13:26,040
而是指示计算机将程序的输出打印到控制台，

182
00:13:26,040 --> 00:13:30,690
程序完成后，控制台上将显示 7。如您所见，

183
00:13:30,690 --> 00:13:34,879
控制台允许我们轻松地将信息打印出来供开发人员用于各种用途。

184
00:13:34,879 --> 00:13:37,930
值得注意的是，打印语句因所使用的编程语言而异。

185
00:13:37,930 --> 00:13:42,320
例如，在 Java中，打印语句有多个版本，具体取决于

186
00:13:42,320 --> 00:13:46,770
您是否希望在打印的文本后换行，以及使代码更高效的

187
00:13:46,770 --> 00:13:51,430
专用打印语句。此外，使用打印语句的一般语法

188
00:13:51,430 --> 00:13:55,880
及其功能的某些细微差别可能会因语言而异。但是，您通常

189
00:13:55,880 --> 00:14:00,490
可以依赖它执行相同的总体功能，因为它是一般编程的

190
00:14:00,490 --> 00:14:02,040
基础语句。因此，打印语句会将信息打印到控制台供开发人员

191
00:14:02,040 --> 00:14:03,040
使用，很棒。

192
00:14:03,040 --> 00:14:06,320
所有这些功能使得 print 语句和控制台成为非常有用的开发工具

193
00:14:06,320 --> 00:14:11,630
但是，重要的是要记住，它仅此而已：一个开发工具。

194
00:14:11,630 --> 00:14:15,360
控制台实际上并不是供程序的最终用户查看的。它往往

195
00:14:15,360 --> 00:14:18,820
隐藏在幕后，而是使用其他显示信息的方法例如

196
00:14:18,820 --> 00:14:23,570
显示文本、图形或图像来向用户传达信息。

197
00:14:23,570 --> 00:14:27,070
可以这样想，当你使用手机时，你使用的任何程序都不会

198
00:14:27,070 --> 00:14:30,810
显示控制台。因此，虽然你可以使用控制台来获

199
00:14:30,810 --> 00:14:34,370
取有关程序运行情况的信息，但不要尝试在最终产品中实现它，因为

200
00:14:34,370 --> 00:14:38,900
它从根本上来说并不是为此而设计的。总的来说，在编写和修复程序中的问题时，

201
00:14:38,900 --> 00:14:43,590
请记住充分利用控制台在编写和修复程序问题时，它可以最大限度地发挥其作用，

202
00:14:43,590 --> 00:14:48,320
因为它是一个很好的工具，可以用来了解程序在后台的运行情况。

203
00:14:48,320 --> 00:14:52,061
现在我们已经了解了大量有关编程语言的信息，以及如何以及在何处

204
00:14:52,061 --> 00:14:56,420
编写它们，并且掌握了 print 语句，让我们来看看

205
00:14:56,420 --> 00:15:00,810
计算机可以自行完成的一些直观的事情，而无需您告诉它如何做。更

206
00:15:00,810 --> 00:15:05,910
具体地说，我们将介绍基本的数字数学以及字符串数学。

207
00:15:05,910 --> 00:15:10,310
从基础数学开始，计算机已经知道如何进行简单的算术运算。

208
00:15:10,310 --> 00:15:15,110
这包括加法、减法、乘法和除法，所有这些都用

209
00:15:15,110 --> 00:15:19,490
屏幕上现在显示的符号表示。在您安装的任何 IDE 中，您都

210
00:15:19,490 --> 00:15:23,310
可以使用 print 语句打印出简单数学问题的答案，这

211
00:15:23,310 --> 00:15:26,900
似乎有悖常理，因为当您的手机上有一个完好的计算器时，为什么还要

212
00:15:26,900 --> 00:15:31,360
使用计算机来做数学题呢？但您必须记住，计算机是

213
00:15:31,360 --> 00:15:36,820
愚蠢的，我们想让计算机做的任何事情都必须从头开始。基本算术

214
00:15:36,820 --> 00:15:42,260
虽然简单，但几乎可以帮到您编写的任何程序。例如，如果我们想要

215
00:15:42,260 --> 00:15:46,630
构建一个基本的计算器应用程序，我们需要利用此功能，以便

216
00:15:46,630 --> 00:15:52,150
在用户尝试对两个数字进行加、减、乘或除时

217
00:15:52,150 --> 00:15:54,690
正确显示算术问题的答案。

218
00:15:54,690 --> 00:15:59,150
现在，除了 4 个基本数学等式之外，大多数编程语言都包含一个称为

219
00:15:59,150 --> 00:16:04,029
模数的附加运算符。如果这是你第一次听到这个词，请不要担心，

220
00:16:04,029 --> 00:16:08,710
因为它通常不会在数学课上教授。模数使我们能够得到

221
00:16:08,710 --> 00:16:14,250
除法运算的余数。例如，当我们取 10 模 3 时，我们实际上是在告诉

222
00:16:14,250 --> 00:16:19,730
计算机取 10，除以 3，忽略实际答案，只给出该运算的

223
00:16:19,730 --> 00:16:25,430
余数（本例中为 1），因为当我们将 10 除以 3 时，答案是 3 余数 

224
00:16:25,430 --> 00:16:32,250
1。本例中的 1 会打印到控制台。如果没有余数，

225
00:16:32,250 --> 00:16:37,410
比如我们取 50 模 2，由于余数为 0，如果我们将其

226
00:16:37,410 --> 00:16:41,100
打印出来，函数将返回 0。

227
00:16:41,100 --> 00:16:45,830
这在很多情况下都非常有用，最明显的例子就是我们想确定

228
00:16:45,830 --> 00:16:52,050
某个整数是偶数还是奇数。如果我们取某个数模 2，

229
00:16:52,050 --> 00:16:57,790
结果返回 0，那么我们就知道它是偶数，因为任何偶数除以 2 都会

230
00:16:57,790 --> 00:17:02,830
得到一个完整的答案而没有余数，但如果系统返回 1，那么

231
00:17:02,830 --> 00:17:07,400
我们就知道这个整数是奇数。你会发现自己使用基本数学运

232
00:17:07,400 --> 00:17:11,569
算符的次数比你想象的要多得多，所以在编写程序时最好记住它们。

233
00:17:11,569 --> 00:17:17,749
现在我们的计算机可以处理数字和字符串。顺便说一下，字符串是另一种

234
00:17:17,749 --> 00:17:22,299
表示文本的方式。例如，“hello world”是一个字符串，字母“a”是

235
00:17:22,299 --> 00:17:27,970
一个字符串，在编程语言中，任何用引号括起来的东西都表示为字符串。

236
00:17:27,970 --> 00:17:32,010
稍后讨论变量时，我们会更多地介绍字符串，但现在

237
00:17:32,010 --> 00:17:36,090
我们先继续。我们已经讨论过将字符串打印到控制台，但

238
00:17:36,090 --> 00:17:39,080
假设我们正在制作一个游戏，我们想要打印出语句

239
00:17:39,080 --> 00:17:44,269
“游戏结束，4 是你的最终得分”。现在，虽然我们可以创建一个字符串来

240
00:17:44,269 --> 00:17:48,549
表达这个确切的短语，并将其打印到控制台，但在某些情况下，打印出

241
00:17:48,549 --> 00:17:52,590
实际的整数值会更有用，尤其是在每次玩游戏时分数都会

242
00:17:52,590 --> 00:17:57,149
发生变化的游戏中，因为分数肯定不会总是 4。

243
00:17:57,149 --> 00:18:03,039
好吧，我们还可以通过在打印语句中将它们“相加”

244
00:18:03,039 --> 00:18:08,499
来打印多个文本字符串，甚至整数。这称为连接。

245
00:18:08,499 --> 00:18:12,769
继续我们的分数示例。如果我们想打印出语句“游戏结束，4 

246
00:18:12,769 --> 00:18:17,429
是你的最终分数”，使用 4 作为整数而不是字符串，我们可以通过

247
00:18:17,429 --> 00:18:21,919
将语句分解为两个字符串和一个整数来实现，如下所示。

248
00:18:21,919 --> 00:18:27,740
print (“Game over, “ + 4 + “ was your
final score)

249
00:18:27,740 --> 00:18:34,980
我们当然从打印语句开始，这在所有语言中都会有所不同。

250
00:18:34,980 --> 00:18:39,240
在打印语句中，我们首先打印字符串 “Game over” 。现在

251
00:18:39,240 --> 00:18:44,549
到了重要的部分，从那里，我们使用加号并将 4 添加

252
00:18:44,549 --> 00:18:48,779
到打印语句中，就像您将两个数字相加一样。然后，我们可以用

253
00:18:48,779 --> 00:18:54,090
另一个 + 号重复此过程，得到最后一个字符串“ was your final score”，这样我们

254
00:18:54,090 --> 00:18:59,029
就可以轻松地打印出整个语句。这样，我们就可以轻松地在一个打印语句中

255
00:18:59,029 --> 00:19:03,270
打印出多个不同的字符串和整数。

256
00:19:03,270 --> 00:19:08,070
我们还可以结合迄今为止学到的两节课，做类似“游戏结束，

257
00:19:08,070 --> 00:19:14,369
“ + (4+4) + ”是你的最终得分”的事情，假设我们有一个游戏，

258
00:19:14,369 --> 00:19:19,860
它会给你一个基本分数，然后你完成某项任务会得到 4 分。这个演示

259
00:19:19,860 --> 00:19:24,640
还展示了编程的另一个重要部分，那就是，很多时候为了让你的程序

260
00:19:24,640 --> 00:19:28,720
最高效，你必须结合代码的各个方面。

261
00:19:28,720 --> 00:19:32,200
现在需要注意的是，计算机将接受括号中的内容并逐个

262
00:19:32,200 --> 00:19:36,590
字符地打印出来，因此程序员经常会忘记在字符串

263
00:19:36,590 --> 00:19:41,049
末尾添加空格。这可能会导致一个小错误，即上一个

264
00:19:41,049 --> 00:19:44,179
示例中的字符串将被打印出来，好像在说

265
00:19:44,179 --> 00:19:48,690
“游戏结束，4 是你的最终得分”，当显示在屏幕上时，用户会感到

266
00:19:48,690 --> 00:19:53,999
不舒服，因此最好始终在字符串前后添加一个空格，

267
00:19:53,999 --> 00:19:58,240
以确保不会发生这种情况，并且字符串不会像这样结束。

268
00:19:58,240 --> 00:20:03,650
另一个需要注意的重要事项是带引号的“4”和不带引号的“4”之间的

269
00:20:03,650 --> 00:20:09,389
区别。现在带引号的“4”被视为字符串，而不带引号的

270
00:20:09,389 --> 00:20:14,530
“4”被视为数字。这似乎不是什么大

271
00:20:14,530 --> 00:20:19,230
问题，但计算机很笨，如果你尝试对带引号的数字

272
00:20:19,230 --> 00:20:23,149
进行数学运算，它会返回错误，因为计算机不明白你试图

273
00:20:23,149 --> 00:20:27,190
对数字执行运算，它认为你试图将整数添加到

274
00:20:27,190 --> 00:20:33,350
字符串中，这在编程中是大忌。因此，在编程时，请务必记住

275
00:20:33,350 --> 00:20:37,580
是否要将某个东西设为整数或字符串，因为

276
00:20:37,580 --> 00:20:42,500
这类东西会产生很大的不同。好的，关于计算机基本功能的部分

277
00:20:42,500 --> 00:20:45,090
到此结束。

278
00:20:45,090 --> 00:20:48,190
接下来我们将介绍计算机科学中最重要的组成部分

279
00:20:48,190 --> 00:20:52,970
之一，所以请务必注意，因为接下来我们将介绍变量、它们是什么以及

280
00:20:52,970 --> 00:20:55,159
我们如何使用它们。

281
00:20:55,159 --> 00:20:59,789
首先，变量到底是什么？变量简单来说就是可以存储

282
00:20:59,789 --> 00:21:05,419
信息，可以被引用和操作的东西。把变量想象成一个纸板箱。纸板箱

283
00:21:05,419 --> 00:21:10,940
可以作为存储物品的手段，其中的物品可以进行更换、替换和修改。

284
00:21:10,940 --> 00:21:14,059
变量就像纸板箱，里面存储着程序员可以引用、

285
00:21:14,059 --> 00:21:18,659
操作和参考的信息。每个变量都只具有类型、名称和存储在其

286
00:21:18,659 --> 00:21:22,610
中的信息。类型和信息将在下文中介绍，名称只是变量

287
00:21:22,610 --> 00:21:26,350
的名称，可以将其视为用记号笔在纸板箱上

288
00:21:26,350 --> 00:21:27,769
写的标签。

289
00:21:27,769 --> 00:21:32,570
现在，程序员可以使用许多不同类型的变量，但现在我们只介绍

290
00:21:32,570 --> 00:21:36,640
所谓的“原始变量”，其中包括整数、布尔值、

291
00:21:36,640 --> 00:21:40,090
浮点数和双精度数、字符串和字符。

292
00:21:40,090 --> 00:21:46,549
我们首先讨论整数。整数（或简称为 int）听起来

293
00:21:46,549 --> 00:21:51,539
很简单：一个可以存储整数值的变量。这包括从 

294
00:21:51,539 --> 00:22:04,090
-2,147,483,648 到 2,147,483,648 的所有整数。现在请注意我说的是整数，整数

295
00:22:04,090 --> 00:22:09,869
变量不能也不会保存任何小数值，因此在使用变量时请记住这一点。

296
00:22:09,869 --> 00:22:13,549
第二个是布尔值。布尔值是一个非常原始的

297
00:22:13,549 --> 00:22:19,169
变量，可以存储 true 或 false 的值。布尔变量只能保存这两个值，并且

298
00:22:19,169 --> 00:22:22,740
对于条件语句非常有用，我们将很快介绍这些条件语句。

299
00:22:22,740 --> 00:22:26,740
接下来的两种变量类型是浮点数和双精度数。这两种变量类

300
00:22:26,740 --> 00:22:30,679
型都是浮点数据类型，这本质上意味着这些变量可以存储带有

301
00:22:30,679 --> 00:22:36,299
小数位的数字。整数值不能容纳小数，而浮点数和双精度数

302
00:22:36,299 --> 00:22:40,760
可以。两者之间的主要区别在于浮点数变量可以存储精度

303
00:22:40,760 --> 00:22:45,730
高达 32 位的数字，而双精度数可以存储精度高达 64 位的数字。

304
00:22:45,730 --> 00:22:50,299
本质上，双精度数可以比浮点数存储更多的小数位，因此一切

305
00:22:50,299 --> 00:22:52,460
都取决于您希望变量有多精确。

306
00:22:52,460 --> 00:22:55,580
接下来我们有字符串变量，它们类似于我们之前讨论过的字符串，

307
00:22:55,580 --> 00:23:01,440
只是存储在值的某个地方。字符串变量可以存储字母串，

308
00:23:01,440 --> 00:23:05,039
这些字母串就是单词和句子。字符串可用于显示文本和存储

309
00:23:05,039 --> 00:23:09,929
输入信息。字符串也可以连接在一起形成字符串变量和预先写好的

310
00:23:09,929 --> 00:23:14,159
字符串的组合。这对于以用户可读的格式输出信息非常

311
00:23:14,159 --> 00:23:18,049
有用。例如，假设我们有一个名为“name”的字符串。代码

312
00:23:18,049 --> 00:23:22,279
要求输入，并将该字符串存储在 name 中。要将此信息

313
00:23:22,279 --> 00:23:25,809
输出给用户，而不是简单地显示他们的姓名，您可以添加短语“您的

314
00:23:25,809 --> 00:23:31,389
名字是：” 并通过连接 “您的名字是：” + name +“。”将其变成一个句子。

315
00:23:31,389 --> 00:23:36,049
这使您的代码更易于阅读，同时也为代码增加了可变性，这

316
00:23:36,049 --> 00:23:38,820
总是会让最终用户觉得更有趣。

317
00:23:38,820 --> 00:23:43,879
最后，我们有 char 变量。char 代表字符，顾名思义，

318
00:23:43,879 --> 00:23:47,629
每个变量都可以容纳一个字符。当程序员想要读取一次按钮按下

319
00:23:47,629 --> 00:23:51,870
或字符串中的一个字符而不使用字符串变量时，这很有用。一个具体

320
00:23:51,870 --> 00:23:55,609
的例子是制作一个由键盘控制的游戏。程序需要识别

321
00:23:55,609 --> 00:24:00,160
按下的字符，并将其转换为执行某些功能。

322
00:24:00,160 --> 00:24:03,799
字符串也可以容纳一个字符，但 char 不能容纳多个字符，因此

323
00:24:03,799 --> 00:24:05,759
在定义变量时请记住这一点。

324
00:24:05,759 --> 00:24:10,929
那么，变量为什么如此有用呢？因为能够以一种以后可以轻松引用的

325
00:24:10,929 --> 00:24:15,510
格式存储信息对于任何优秀的程序来说都是必不可少的。在代码中，

326
00:24:15,510 --> 00:24:19,450
您经常需要跟踪诸如用户姓名或分数之类的信息，因此，通过创建

327
00:24:19,450 --> 00:24:23,019
一个名为“name”或“score”的变量，您可以将这些信息

328
00:24:23,019 --> 00:24:27,250
存储在该变量中，然后引用、添加或修改它。此外，很多时候，程序

329
00:24:27,250 --> 00:24:31,190
必须从用户那里获取输入，而这些输入无法预先编入代码中，因此

330
00:24:31,190 --> 00:24:35,200
需要一个变量来存储信息。程序还可能依赖于会随着程序的进展

331
00:24:35,200 --> 00:24:40,190
而改变的因素，在这种情况下，再次需要一个变量。此外，

332
00:24:40,190 --> 00:24:43,400
获取这些变量并对其进行操作对于执行您希望程序执行的许多

333
00:24:43,400 --> 00:24:47,129
任务（例如乘以 int 变量或

334
00:24:47,129 --> 00:24:52,111
连接字符串变量）非常必要。总体而言，变量是任何优秀程序的支柱，如果

335
00:24:52,111 --> 00:24:56,279
您想要简洁高效的代码，您会发现自己经常使用它们，因此最好

336
00:24:56,279 --> 00:24:59,179
了解需要使用哪些类型的变量以及何时使用。

337
00:24:59,179 --> 00:25:02,330
现在我们已经了解了所有不同的变量类型，并对它们进行了一些

338
00:25:02,330 --> 00:25:06,470
讨论，现在我们将进一步深入研究当我们实际定义或创建变量时会发生

339
00:25:06,470 --> 00:25:12,000
什么，我们如何引用它们，以及如何为我们的程序操作它们。

340
00:25:12,000 --> 00:25:16,559
首先，让我们回顾一下定义变量时会发生什么。现在，当我们编写一行

341
00:25:16,559 --> 00:25:21,929
初始化变量的代码并执行该代码时，计算机实际上

342
00:25:21,929 --> 00:25:26,489
会在内存中创建一个小空间来存储变量名称及其内容，

343
00:25:26,489 --> 00:25:32,350
以便以后引用。回到我们的纸板箱示例。想象一下，

344
00:25:32,350 --> 00:25:37,749
如果你有一个存储设施，你制作了一个新的纸板箱，标有“名称”，并在

345
00:25:37,749 --> 00:25:42,230
里面放了一张纸，上面写着“NullPointerException”。

346
00:25:42,230 --> 00:25:46,960
现在，任何时候您想知道名称框的内容，您只需查看内部即可发

347
00:25:46,960 --> 00:25:52,789
现它包含内容“NullPointerException”。这就是计算机所做的，只不过

348
00:25:52,789 --> 00:25:59,119
存储设施是内存，盒子是变量，盒子的内容是变量设置为

349
00:25:59,119 --> 00:26:04,730
相等的内容。任何时候你想知道名称变量的内容，

350
00:26:04,730 --> 00:26:09,169
你都可以简单地调用它，计算机就会提取存储在该变量中的信息，并按照

351
00:26:09,169 --> 00:26:13,630
用户认为合适的方式使用它。

352
00:26:13,630 --> 00:26:17,429
需要快速注意的另一件事是，您实际上可以创建一个变量而不在

353
00:26:17,429 --> 00:26:22,999
其中放入信息。这就像您制作一个新的纸板箱，用记号笔给它贴上

354
00:26:22,999 --> 00:26:27,629
标签，但没有在其中放入信息。您只是

355
00:26:27,629 --> 00:26:33,759
在仓库中保存了空间以备后用。这可能是因为你希望以后能将

356
00:26:33,759 --> 00:26:37,509
信息存储在其中，或者如果您要使用它来存储用户提

357
00:26:37,509 --> 00:26:41,610
供的信息，在这种情况下您无法向它提供信息，因为您不知道

358
00:26:41,610 --> 00:26:47,570
用户将输入什么。请注意，如果您尝试引用或指向一个没有

359
00:26:47,570 --> 00:26:52,280
任何信息的变量，您将得到所谓的 NullPointerException，

360
00:26:52,280 --> 00:26:55,640
尽管这对于 YouTube 频道来说是一个很棒的名称，但在编程时

361
00:26:55,640 --> 00:26:57,760
通常要避免这种情况。

362
00:26:57,760 --> 00:27:01,789
现在，编程语言允许我们用我们创建的这些“盒子”做一些

363
00:27:01,789 --> 00:27:07,820
非常酷的事情。例如，假设我们创建了第二个变量“channelName”，

364
00:27:07,820 --> 00:27:12,950
而不是将其设置为“NullPointerException”，而是将其设置为我们已经创建的

365
00:27:12,950 --> 00:27:18,230
“Name”变量。这不会在内存中为这个新变量创建空间；但是，

366
00:27:18,230 --> 00:27:23,320
它只是指向我们已经为“Name”变量创建的内存的

367
00:27:23,320 --> 00:27:27,929
相同位置。回到我们的存储设施示例，如果我们不是创建

368
00:27:27,929 --> 00:27:31,799
一个标有“channelName”的全新盒子并存储一张写有

369
00:27:31,799 --> 00:27:37,759
“NullPointerException”字样的纸，而是在“Name”框下方添加另一个

370
00:27:37,759 --> 00:27:43,109
标签，标题为“channelName”。现在，我们有两个变量，但都指向相同的

371
00:27:43,109 --> 00:27:48,729
内容，即字符串“NullPointerException”。
我们通常这样做是为了节省代码中的空间，

372
00:27:48,729 --> 00:27:52,110
因为我们知道这些内容会具有相同的值。

373
00:27:52,110 --> 00:27:56,690
变量也可以在整个代码中更新。例如，假设你有一个“Age”

374
00:27:56,690 --> 00:28:02,009
变量，里面有整数 17。然后你庆祝了生日并想

375
00:28:02,009 --> 00:28:06,700
更新你的年龄。你所要做的就是引用变量，并将其设置为

376
00:28:06,700 --> 00:28:12,049
你想要变量保存的任何新整数，在本例中为18。这相当

377
00:28:12,049 --> 00:28:16,320
于有一个标有年龄的盒子，里面有一张写着17 的纸，然后

378
00:28:16,320 --> 00:28:22,139
取出那张纸，擦除 17，用 18 替换，然后放回

379
00:28:22,139 --> 00:28:27,129
盒子里。这样做，我们能够随着事物的动态变化，

380
00:28:27,129 --> 00:28:31,850
在整个代码中轻松更新变量的内容。再举一个例子，如果你正在制作

381
00:28:31,850 --> 00:28:38,640
RPG，你的角色可能会有攻击、防御、法力等属性。随着

382
00:28:38,640 --> 00:28:42,590
游戏的进展，你可以不断更新变量，这样玩家在

383
00:28:42,590 --> 00:28:46,350
游戏中越走越远，就越强大，而你不必

384
00:28:46,350 --> 00:28:50,590
创建新的变量。你只需要不断地从你的

385
00:28:50,590 --> 00:28:55,080
存储设施中取出那个盒子，擦除并替换纸上的数字，然后

386
00:28:55,080 --> 00:28:59,359
继续你的代码。请记住，这些变量只不过是

387
00:28:59,359 --> 00:29:04,210
内存中存储特定值的位置，因此我们可以轻松更新数字，

388
00:29:04,210 --> 00:29:09,369
并且它们的位置将保持不变。代码运行完毕后，内存中的位置

389
00:29:09,369 --> 00:29:13,509
将被删除，直到您再次运行代码并且程序再次为变量分配

390
00:29:13,509 --> 00:29:18,729
空间。每次运行代码时，您都会在存储设施中创建新的盒子，

391
00:29:18,729 --> 00:29:23,840
并且在代码结束时，您会销毁所有盒子以便下次为新盒子腾出空间。

392
00:29:23,840 --> 00:29:29,269
变量的另一项有趣功能是加、减、乘、除，

393
00:29:29,269 --> 00:29:32,880
甚至取模。现在这主要只适用于整数变量，

394
00:29:32,880 --> 00:29:33,929
因为对字符串进行乘法和除法没有太大意义。但是，如果您正在制作

395
00:29:33,929 --> 00:29:39,102
一个计算器应用程序，并将用户输入的第一个数字存储为 num1，将第二个

396
00:29:39,102 --> 00:29:45,140
数字存储为 num2。然后，您可以将 num1 和 num2 相乘，然后打印它们，或

397
00:29:45,140 --> 00:29:50,759
将它们存储在名为 result的新变量中。然后，每次运行程序时，用户都可以

398
00:29:50,759 --> 00:29:55,990
将新数字输入到 num1 和 num2 变量中，它们将被设置为这些新

399
00:29:55,990 --> 00:30:02,860
整数并返回与这些特定数字相对应的结果。这使

400
00:30:02,860 --> 00:30:07,029
您可以轻松跟踪哪些数字是哪些数字以及程序中发生了什么，

401
00:30:07,029 --> 00:30:12,509
这非常有用。此外，虽然您不能对字符串进行减法、乘法、除法或取模，

402
00:30:12,509 --> 00:30:19,590
但您可以将它们相加。假设您有一个字符串 Str1，

403
00:30:19,590 --> 00:30:26,029
其内容为“Hello ”，还有一个字符串 Str2，其内容为“there”。您可以将 Str1 

404
00:30:26,029 --> 00:30:31,269
和 Str2 相加，以创建一个字符串，其内容为“Hello there”，要么将其存储在

405
00:30:31,269 --> 00:30:34,500
第三个变量中，要么将其打印到控制台。

406
00:30:34,500 --> 00:30:38,259
关于变量，我们将要讨论的最后一个主题是变量的命名

407
00:30:38,259 --> 00:30:43,179
约定，虽然这看起来很奇怪，但在尝试阅读代码时它

408
00:30:43,179 --> 00:30:49,249
非常重要，所以我们现在就讨论它。变量必须是一个连续的字符串，

409
00:30:49,249 --> 00:30:53,120
因此，如果你想创建一个存储玩家得分的变量，你必须找到

410
00:30:53,120 --> 00:30:58,000
某种方法来组合单词 player 和 score，因为你不能将短语 “player

411
00:30:58,000 --> 00:31:02,549
score” 用作变量的名称。所有程序员在命名变量时都有

412
00:31:02,549 --> 00:31:07,570
自己的个人偏好，但在本讲座中我们将使用 CamelCase 命名法，

413
00:31:07,570 --> 00:31:11,960
即不将第一个单词大写，而是将后面的每个单词

414
00:31:11,960 --> 00:31:17,919
大写。回到玩家得分示例，使用 camelCase 方法，变量

415
00:31:17,919 --> 00:31:23,760
将被称为 playerScore。这使我们能够轻松识别每个单词，并且对于像

416
00:31:23,760 --> 00:31:31,259
“thePlayersScoreBeforeFinalBoss”这样的长变量名非常有用，
而如果我们只是将其输入而不使用大写，

417
00:31:31,259 --> 00:31:38,380
则会非常令人困惑。当你开始在代码中发现

418
00:31:38,380 --> 00:31:42,789
错误并需要快速扫描程序以找出错误时，这将大有帮助，

419
00:31:42,789 --> 00:31:48,239
并增加了程序的整体可读性。其他程序员可能会使用不同的命名约定，

420
00:31:48,239 --> 00:31:53,559
例如使用下划线来分隔短语中的单词，但现在我们将坚持使用

421
00:31:53,559 --> 00:31:54,789
驼峰式命名法。

422
00:31:54,789 --> 00:32:00,190
接下来，我们将讨论条件语句，其核心是

423
00:32:00,190 --> 00:32:04,049
根据特定条件更改代码路径的语句。为了简单起见

424
00:32:04,049 --> 00:32:07,659
在本节中，红线表示我们的代码不会遵循该

425
00:32:07,659 --> 00:32:12,860
特定路径，绿线表示我们的代码遵循该路径。

426
00:32:12,860 --> 00:32:17,460
程序员使用的主要条件语句类型是 if 语句，它会

427
00:32:17,460 --> 00:32:21,749
在您编写的任何程序中出现无数次。它听起来

428
00:32:21,749 --> 00:32:27,380
很简单：如果某个条件为真（通常该条件用括号

429
00:32:27,380 --> 00:32:33,090
括起来），则执行 if 语句括号内的指令。否则，

430
00:32:33,090 --> 00:32:36,919
执行另一件事。大多数编程语言都

431
00:32:36,919 --> 00:32:42,649
使用括号来指示将要运行的一段代码。它的工作原理是，如果括号

432
00:32:42,649 --> 00:32:47,169
中的条件为真，则括号内包含的所有代码都将运行，

433
00:32:47,169 --> 00:32:51,809
如果括号中的条件不为真，则它将跳过括号内的

434
00:32:51,809 --> 00:32:56,619
所有语句。需要注意的是，虽然大多数编程语言都是这种

435
00:32:56,619 --> 00:33:01,769
情况，但有些语言（如Python）使用冒号和空格来确定一段代码的

436
00:33:01,769 --> 00:33:07,249
开始和结束位置，但为了本系列的目的，我们将使用花括号。

437
00:33:07,249 --> 00:33:12,179
括号内的条件可以有数千种不同的形式，例如，

438
00:33:12,179 --> 00:33:17,840
如果字符串变量 Name 的值等于“Steven”，或者存储在 int

439
00:33:17,840 --> 00:33:22,460
变量中的玩家得分大于5，等等。这些语句

440
00:33:22,460 --> 00:33:26,779
中的每一个都被评估为布尔值，您会记得，当我们讨论

441
00:33:26,779 --> 00:33:32,610
变量时，布尔值是真或假。如果布尔值为真，我们将运行

442
00:33:32,610 --> 00:33:38,279
花括号内的代码，如果不是，我们假装花括号内的所有内容都不存在，

443
00:33:38,279 --> 00:33:40,970
然后继续执行我们的代码。

444
00:33:40,970 --> 00:33:45,359
语句还有另外两个可以与之配合使用的附加语句：else if 和

445
00:33:45,359 --> 00:33:50,549
else。Else if 是直接在 if 语句之后使用的条件语句，

446
00:33:50,549 --> 00:33:55,620
其功能与 if 语句基本相同。但是，仅当前面的 if（或 else if）

447
00:33:55,620 --> 00:34:01,789
语句由于其条件为假而被绕过时，才会评估 else if 

448
00:34:01,789 --> 00:34:07,500
语句。因此，我们将像这样运行它，如果某项为真，我们将运行

449
00:34:07,500 --> 00:34:12,810
该语句花括号内的代码。否则，如果某件事不成立，但

450
00:34:12,810 --> 00:34:18,280
括号内的另一个语句为真，我们就会运行该代码段。如果两个

451
00:34:18,280 --> 00:34:22,940
语句都不为真，我们将跳过这两个代码段并继续执行程序。

452
00:34:22,940 --> 00:34:27,330
这是一个很难理解的概念，所以让我们举个例子。如果我们

453
00:34:27,330 --> 00:34:32,169
有一个程序评估 if (age = 10)，那么我们可以在该语句下有一个语句，

454
00:34:32,169 --> 00:34:38,120
该语句声明 else if (age = 12)。现在，如果 age 变量是 10（我们可以从

455
00:34:38,120 --> 00:34:42,120
示例中看到），那么紧跟在括号中的条件语句后面的代码将

456
00:34:42,120 --> 00:34:46,040
运行。我们编写的 else if 语句甚至不会被测试，因为

457
00:34:46,040 --> 00:34:49,970
我们知道它会是错误的，因此，条件语句括号内的

458
00:34:49,970 --> 00:34:54,230
打印语句将被忽略，代码将转到程序的其余部分。

459
00:34:54,230 --> 00:34:59,640
现在，例如，假设我们将 age 变量改为 12 而不是 10。现在，

460
00:34:59,640 --> 00:35:02,710
第一个条件语句不再为真，而是实际为假，

461
00:35:02,710 --> 00:35:07,400
因为 age 不是 10。所以我们现在要做的是，首先跳过打印出

462
00:35:07,400 --> 00:35:11,690
 age 为 10 的 print 语句，因为它不是。现在我们评估 else if

463
00:35:11,690 --> 00:35:15,740
语句。我们检查年龄是否等于 12，结果再次为 12，因此现在我们

464
00:35:15,740 --> 00:35:19,750
运行该条件语句内的所有代码，然后最终转到程序的其余

465
00:35:19,750 --> 00:35:20,850
部分。

466
00:35:20,850 --> 00:35:25,380
作为复习，我们检查 if 语句，如果正确，我们将运行该 if

467
00:35:25,380 --> 00:35:29,380
语句花括号内的所有代码并继续执行程序，如果初始 if

468
00:35:29,380 --> 00:35:33,740
语句不为真，我们将转到任何 else if 语句并评估*这些*条件语句

469
00:35:33,740 --> 00:35:37,640
是否为真。我们可以拥有任意数量的语句，尽管这

470
00:35:37,640 --> 00:35:40,970
可能会导致代码混乱，因此我们稍后将讨论一些替代方案来帮助解决

471
00:35:40,970 --> 00:35:44,840
这个问题。现在，这已经处理了 if-else 语句，因此现在我们将转到 

472
00:35:44,840 --> 00:35:46,500
else 语句。

473
00:35:46,500 --> 00:35:50,320
else 语句再次位于 if 或 else if 语句之后，只要

474
00:35:50,320 --> 00:35:54,790
前面的语句被评估为 false，它就会无论如何执行

475
00:35:54,790 --> 00:35:59,660
其指令。如果我们回到之前的程序，我们可以添加一个 else 语句，

476
00:35:59,660 --> 00:36:03,080
只有当 age 变量不是“10”或“12”时，才会运行括号中的

477
00:36:03,080 --> 00:36:07,180
代码。这将捕获程序中所有不符合我们参数的情况。

478
00:36:07,180 --> 00:36:10,440
最好总是在条件语句的末尾添加一个 else 语句，以捕获程序中

479
00:36:10,440 --> 00:36:13,920
可能出现的任何奇怪情况。

480
00:36:13,920 --> 00:36:17,531
现在回想一下，我们可能会有数千个 else if 语句，一段

481
00:36:17,531 --> 00:36:21,170
时间后，这些语句会变得非常混乱，因此，另一个非常有用的条件语句

482
00:36:21,170 --> 00:36:24,700
可以帮助解决这个问题，那就是 switch 语句。 switch 语句

483
00:36:24,700 --> 00:36:28,730
的功能类似于许多 if 和 else if 语句的组合。您可以以

484
00:36:28,730 --> 00:36:32,250
 switch (变量) 的形式编写 语句，然后在其下方写出变量可以有多少种

485
00:36:32,250 --> 00:36:36,080
情况。例如，如果我们写了 switch(var)，那么我们可以在其下方写出

486
00:36:36,080 --> 00:36:39,890
变量 var 可以有的 5 种情况，然后写出如果 var switch 变量

487
00:36:39,890 --> 00:36:43,990
等于该情况，则在该情况下要执行的指令。

488
00:36:43,990 --> 00:36:47,280
switch 语句有所不同，因为它们不使用括号，而是使用冒号

489
00:36:47,280 --> 00:36:51,740
来表示一组指令的开始，并使用 break 语句来结束它。这非常

490
00:36:51,740 --> 00:36:55,460
有用，因为您基本上可以使用许多 if 和 else if 语句，

491
00:36:55,460 --> 00:36:59,280
而不必编写那么多代码。在 switch 语句中，您只需始终记住

492
00:36:59,280 --> 00:37:03,340
在表达式的底部包含一个默认情况，以表示任何和

493
00:37:03,340 --> 00:37:06,990
所有不符合上述要求的情况。这捕获了所有

494
00:37:06,990 --> 00:37:10,570
不符合程序主案例的输入。这很像 if-else 链结尾的

495
00:37:10,570 --> 00:37:11,820
 else case。

496
00:37:11,820 --> 00:37:16,580
那么，为什么这些语句如此有用呢？很多时候，程序员希望他们的程序

497
00:37:16,580 --> 00:37:20,210
根据不同的条件以不同的方式运行。例如，程序可以

498
00:37:20,210 --> 00:37:24,130
根据用户输入的信息以不同的方式运行，例如，如果用户

499
00:37:24,130 --> 00:37:29,220
年龄在 18 岁以上或 18 岁以下，则允许用户使用程序或不允许使用程序。

500
00:37:29,220 --> 00:37:32,920
或者在视频游戏中，如果用户的经验水平高于某个阈值，我们

501
00:37:32,920 --> 00:37:36,760
可能会想让他们面对更强大的对手。另一个例子是，一个程序可以

502
00:37:36,760 --> 00:37:40,520
根据一天中的时间改变配色方案。或者更简单地说，如果用户按下

503
00:37:40,520 --> 00:37:44,130
按钮，该按钮旨在转到应用程序中的另一个屏幕，程序员只会希望

504
00:37:44,130 --> 00:37:48,450
应用程序在用户单击该按钮时更改屏幕。没有条件语句的程序每次

505
00:37:48,450 --> 00:37:51,870
都会做同样的事情，与可以根据条件更改的程序相比，

506
00:37:51,870 --> 00:37:54,770
它非常原始。

507
00:37:54,770 --> 00:37:59,220
现在我们知道了如何创建和使用变量、如何比较它们以及我们可以

508
00:37:59,220 --> 00:38:04,670
用这些比较做什么，让我们继续讨论计算机科学的另一个基础概念：

509
00:38:04,670 --> 00:38:06,390
数组。

510
00:38:06,390 --> 00:38:09,830
现在我们已经讨论了变量，以及它们对于存储单数位信息以使

511
00:38:09,830 --> 00:38:14,210
我们的代码更加简单有多么重要，但是变量最大的缺点

512
00:38:14,210 --> 00:38:19,490
之一是它们无法保存多条不同的信息。

513
00:38:19,490 --> 00:38:22,950
例如，假设您正在开发一款允许用户创建购物清单的

514
00:38:22,950 --> 00:38:28,510
应用程序。使用变量创建列表并没有真正简单的方法，因为您

515
00:38:28,510 --> 00:38:34,050
无法让一个变量存储 7 或 8 种不同食品的名称。请记住，

516
00:38:34,050 --> 00:38:39,100
我们只能在纸箱中放一张纸；不能再多了。此外，即使

517
00:38:39,100 --> 00:38:43,740
您将多个项目添加到一个字符串变量中，您在执行列表中的简单任务时

518
00:38:43,740 --> 00:38:48,540
仍然会遇到很多麻烦，例如搜索或拆分列表，甚至在完成

519
00:38:48,540 --> 00:38:52,360
任务后从列表中删除项目。这就是使用数组为我们

520
00:38:52,360 --> 00:38:55,680
解决的问题。

521
00:38:55,680 --> 00:39:00,640
您可能已经猜到了，数组就是列表。您可以拥有一个整数数组、

522
00:39:00,640 --> 00:39:04,630
一个字符串数组，甚至一个其他数组的数组，我们将在

523
00:39:04,630 --> 00:39:08,980
稍后介绍。当程序员想要存储大量包含彼此相关信息的变量时，

524
00:39:08,980 --> 00:39:13,700
他们会使用数组，例如购物清单或游戏中的高分

525
00:39:13,700 --> 00:39:18,880
列表。将数组视为 Excel 或 Google 表格中的一列。标题

526
00:39:18,880 --> 00:39:22,950
位于顶部，标题下方是一堆与标题相关的

527
00:39:22,950 --> 00:39:27,510
信息。当程序员想要存储大量易于搜索的信息时，

528
00:39:27,510 --> 00:39:31,410
数组非常有用，因为程序员已经开发出分解和使用数组的方法，

529
00:39:31,410 --> 00:39:36,600
以在包含数千个不同变量的数组中查找特定信息。

530
00:39:36,600 --> 00:39:40,620
举个例子来说明数组有多有用，假设你是一家初创公司，

531
00:39:40,620 --> 00:39:45,660
拥有一款拥有 100,000 名用户的应用程序。每次用户想要创建新帐户时，

532
00:39:45,660 --> 00:39:48,920
他们都会输入他们想要的用户名，然后你的程序必须检查

533
00:39:48,920 --> 00:39:53,060
以确保该帐户名尚未被使用。要做到这一点，您需要搜索所有

534
00:39:53,060 --> 00:39:57,650
 100,000 名用户的信息，以查看该用户名是否拥有您服务

535
00:39:57,650 --> 00:40:02,320
的帐户。数组可以包含所有这些信息，并可以轻松搜索

536
00:40:02,320 --> 00:40:08,280
并找出帐户名称是否已被使用，且几乎没有延迟。

537
00:40:08,280 --> 00:40:12,280
现在，关于数组，最重要的一点是如何引用数组中的

538
00:40:12,280 --> 00:40:16,470
每个元素。让我们创建一个名为“数字”的基本数组，并在其中

539
00:40:16,470 --> 00:40:22,420
放入数字 1-10。当我们想要引用此数组中的每个单元格时，我们会

540
00:40:22,420 --> 00:40:27,140
调用其“索引”。索引只是一种表示数字放置在数组中的

541
00:40:27,140 --> 00:40:32,730
奇特方式。现在，您可能会认为此数组中的第一个整数将是第一个索引，

542
00:40:32,730 --> 00:40:37,920
第二个将是第二个索引，依此类推，但事实并非如此。在计算机科学中，

543
00:40:37,920 --> 00:40:43,450
编程语言将第一个单元格称为数组中的第 0 个元素。

544
00:40:43,450 --> 00:40:47,570
这意味着，如果我们谈论刚刚创建的数字数组，数字

545
00:40:47,570 --> 00:40:52,560
 4 实际上应该在第 3 个索引中，5 应该在第 4，等等，所以我们不是

546
00:40:52,560 --> 00:40:57,420
从 1开始，而是从 0。这非常奇怪和令人困惑，但这是

547
00:40:57,420 --> 00:41:01,080
你必须记住并牢记的编程怪癖之一。

548
00:41:01,080 --> 00:41:04,470
如果您不遵循此命名法，并将此数组中的最后一个元素引用为

549
00:41:04,470 --> 00:41:09,711
第 10 个元素，则会出现所谓的“越界”错误，因为

550
00:41:09,711 --> 00:41:13,790
您尝试引用第 10 个元素，但实际上没有第 10 个元素。您

551
00:41:13,790 --> 00:41:16,850
实际上试图引用的是第 9 个元素。

552
00:41:16,850 --> 00:41:20,891
关于数组，还有一件非常重要的事情需要注意，那就是数组的大小。当

553
00:41:20,891 --> 00:41:25,370
您初始化数组时，有两种方法。您可以立即

554
00:41:25,370 --> 00:41:29,610
用想要包含在数组中的元素填充数组，同时创建

555
00:41:29,610 --> 00:41:34,110
和填充数组，也可以定义想要在数组中包含多少个元素

556
00:41:34,110 --> 00:41:40,140
（本质上是数组大小），然后再用元素填充数组。

557
00:41:40,140 --> 00:41:44,760
这是因为当我们初始化一个数组时，它会在内存中创建一个空间，其大小

558
00:41:44,760 --> 00:41:50,850
恰好等于您指定的值，不多也不少。当我们想要访问数组中的元素时，

559
00:41:50,850 --> 00:42:00,081
这非常有用，因为我们可以立即访问，但一个缺点是我们以后不能增加

560
00:42:00,081 --> 00:42:05,950
数组的大小，所有数组大小都是最终的。想象一下用

561
00:42:05,950 --> 00:42:11,560
书架摆放书籍。通过在书架上放置一定数量的书籍，然后

562
00:42:11,560 --> 00:42:15,780
继续用不同的书籍填充下一个书架。我们无法返回

563
00:42:15,780 --> 00:42:20,690
并在不移动所有内容的情况下将书籍添加到第一个书架。一旦我们决定

564
00:42:20,690 --> 00:42:25,540
在这种情况下为数组分配多少空间，就无法添加更多空间。

565
00:42:25,540 --> 00:42:29,681
再次强调，因为这一点非常重要，所以这意味着一旦定义了

566
00:42:29,681 --> 00:42:34,540
数组，就无法更改其大小。如果您有一个名为

567
00:42:34,540 --> 00:42:39,010
“Names”且大小为 8 的数组，并且您尝试向该数组添加另一个名称，

568
00:42:39,010 --> 00:42:43,810
则会收到错误，因此在调整数组大小时要小心。当然，如果

569
00:42:43,810 --> 00:42:48,110
您发现需要更多空间来容纳项目，您可以随时返回

570
00:42:48,110 --> 00:42:54,340
到最初创建数组时的代码开头并为其分配更多空间，但一旦

571
00:42:54,340 --> 00:42:59,070
定义，您就无法更改其大小。

572
00:42:59,070 --> 00:43:03,120
我想快速提到的另一件小事是，初始化数组时，

573
00:43:03,120 --> 00:43:07,550
必须立即确定数组的类型。例如，在定义数组时，

574
00:43:07,550 --> 00:43:12,310
必须明确说明它是字符串数组还是整数，你还

575
00:43:12,310 --> 00:43:16,060
不允许混合使用，这意味着您不能拥有一个全是数的数组，

576
00:43:16,060 --> 00:43:20,430
整其中混入一些字符串（string）和一些双精度数（double）。它们必须全部

577
00:43:20,430 --> 00:43:21,430
是同一类型。

578
00:43:21,430 --> 00:43:25,250
现在我们要讨论的有关数组的最后一件事是有点奇怪的，那就是

579
00:43:25,250 --> 00:43:29,990
将数组放入数组中的做法。如果你创建了一个数组的数组，它被称为

580
00:43:29,990 --> 00:43:35,290
2D 或二维数组。如果你们中有人上过代数课，可以将它们视为

581
00:43:35,290 --> 00:43:40,200
矩阵。现在，如果你们没有上过，请回想一下我们的Google Sheets 

582
00:43:40,200 --> 00:43:45,830
示例，但不仅仅是列，我们还会添加行。所以现在，我们数组中的每个元素不再

583
00:43:45,830 --> 00:43:50,940
仅仅是一个字符串变量或一个整数变量，而是一个具有自己的一组值和

584
00:43:50,940 --> 00:43:53,590
元素的全新数组。

585
00:43:53,590 --> 00:43:57,930
我们对这些进行索引的方式大致相同，只是我们需要索引 2 个数字而不是

586
00:43:57,930 --> 00:44:04,250
 1 个。我们从行开始，然后从列开始。因此，位置 (0,2) 处的数字将

587
00:44:04,250 --> 00:44:10,690
位于第一行往下三列，在本例中，名字为 Clint。位置

588
00:44:10,690 --> 00:44:16,950
 (1,1) 的数字向下两行，横跨两列，在本例中是Chris 的名字。你

589
00:44:16,950 --> 00:44:22,000
明白我的意思了。你也可以通过将数组嵌套在数组中来创建

590
00:44:22,000 --> 00:44:25,190
三维数组，但这有点超出我们要介绍的范围，所以

591
00:44:25,190 --> 00:44:26,690
我就到此为止了。

592
00:44:26,690 --> 00:44:30,220
接下来我们将讨论循环，那么循环到底是什么？

593
00:44:30,220 --> 00:44:33,980
接下来我们将讨论循环，那么循环到底是什么？

594
00:44:33,980 --> 00:44:37,750
接下来我们将讨论循环，那么循环到底是什么？

595
00:44:37,750 --> 00:44:41,520
接下来我们将讨论循环，那么循环到底是什么？

596
00:44:41,520 --> 00:44:46,000
接下来我们将讨论循环，那么循环到底是什么？

597
00:44:46,000 --> 00:44:49,880
好吧，你可以从话中看出，编程循环是一种用于

598
00:44:49,880 --> 00:44:53,540
重复运行某些指令的语句，就像本主题的开头语句重复了

599
00:44:53,540 --> 00:44:58,880
5 次一样。循环非常有用，原因有很多。例如，

600
00:44:58,880 --> 00:45:02,670
假设您想打印某些内容 15 次。当然，您只需复制并粘贴打印

601
00:45:02,670 --> 00:45:06,640
语句 15 次即可。但这样做真的很烦人，而且当这个数字上升到

602
00:45:06,640 --> 00:45:10,860
100 次左右时就变得更加不现实。现在，如果你不用一遍又一遍地

603
00:45:10,860 --> 00:45:14,280
重写相同的指令，而是简单地将打印语句放在

604
00:45:14,280 --> 00:45:18,010
循环中，它就会按照你想要的次数出现，这就是循环的

605
00:45:18,010 --> 00:45:22,490
力量。使用循环，我们可以多次重复部分代码。

606
00:45:22,490 --> 00:45:27,510
我们将讨论三种不同类型的循环。首先是 for 循环。

607
00:45:27,510 --> 00:45:31,910
for 循环对于上述情况非常有用，在这种情况下，您希望多次执行

608
00:45:31,910 --> 00:45:36,160
一组特定的指令。 for 循环的语法因

609
00:45:36,160 --> 00:45:40,780
语言而异，但通常由三部分组成。一个整数值、一个

610
00:45:40,780 --> 00:45:44,460
整数值必须满足才能退出循环的条件，以及一个在循环内

611
00:45:44,460 --> 00:45:48,570
的指令完成后修改整数值的操作。每次运行 for 

612
00:45:48,570 --> 00:45:52,890
循环时，都会对整数执行您设置的操作，只要该整数

613
00:45:52,890 --> 00:45:56,710
仍然满足您设置的条件（通常大于或小于常数值），

614
00:45:56,710 --> 00:45:59,450
for 循环就会继续运行。

615
00:45:59,450 --> 00:46:03,440
最终，当整数通过增加或减少而被修改到

616
00:46:03,440 --> 00:46:06,860
不再满足条件的程度时，循环将终止，代码将

617
00:46:06,860 --> 00:46:10,760
继续运行。例如，假设我们的整数值为 i，我们将其设置

618
00:46:10,760 --> 00:46:15,330
为 0，然后将条件语句设置为 i 小于 3，因此基本上

619
00:46:15,330 --> 00:46:19,670
我们说只要 i（我们刚刚创建的变量）小于 3，就继续

620
00:46:19,670 --> 00:46:24,390
运行循环中包含的指令。最后，我们进行操作 i++，这意味着

621
00:46:24,390 --> 00:46:27,780
每次循环运行时我们都会将其增加一，在循环内部我们只需放置

622
00:46:27,780 --> 00:46:29,890
一个简单的打印语句。

623
00:46:29,890 --> 00:46:35,330
现在，我们来跑一遍循环。我们开始的时候 i = 0 。0 小于 3，所以我们进入

624
00:46:35,330 --> 00:46:39,610
循环，打印 Hello World。现在指令已经完成，我们将 1 加到 i 上，

625
00:46:39,610 --> 00:46:45,030
使其变为 1。继续，1 再次小于 3，因此我们再次进入循环并打印出

626
00:46:45,030 --> 00:46:50,870
Hello World。再次，我们将 1 加到 i 上，使其变为 2。2 仍然小于 3，因此我们

627
00:46:50,870 --> 00:46:55,380
再次进入循环并打印出 hello world。最后，我们再次将 1 加到 i 上，结果变为

628
00:46:55,380 --> 00:46:59,900
3。3 不小于 3，它等于 3，因此我们不进入循环

629
00:46:59,900 --> 00:47:03,990
并且它会终止，继续执行下一段代码。这是一个简单的例子，

630
00:47:03,990 --> 00:47:06,830
但您可以根据自己的需要在整个编程过程中进行推断。

631
00:47:06,830 --> 00:47:10,280
当使用 for 循环时，您必须确保设置一个条件，

632
00:47:10,280 --> 00:47:14,630
给定初始整数值和操作，在某些时候不会满足，以避免创建

633
00:47:14,630 --> 00:47:18,250
无限循环并使程序崩溃。当你给 for 循环指定一个条件时，

634
00:47:18,250 --> 00:47:21,710
如果给定程序的参数，该条件总是会满足，就会发生无限循环，

635
00:47:21,710 --> 00:47:26,360
因此软件崩溃。例如，for 循环从 10 开始并检查 i 是否

636
00:47:26,360 --> 00:47:29,971
小于 0，然后在循环结束时将 i 加1，该循环永远不会终止，因为

637
00:47:29,971 --> 00:47:32,900
 i 会无限增加。

638
00:47:32,900 --> 00:47:38,110
for 循环之后是非常相似的 for each 循环。for each

639
00:47:38,110 --> 00:47:44,660
循环（在 Python 中为 for-in-list循环）用于迭代数组或列表。

640
00:47:44,660 --> 00:47:50,180
本质上，循环将遍历数组中的每个元素并针对每个值执行一组指令。

641
00:47:50,180 --> 00:47:54,250
如果您想要读取数组中的所有元素并将它们与某个值进行比较，

642
00:47:54,250 --> 00:48:00,270
或者对它们执行某些操作，那么 for each 循环非常有用。

643
00:48:00,270 --> 00:48:04,280
例如，我们可以有一个 for each 循环，它遍历整个数组

644
00:48:04,280 --> 00:48:07,780
并简单地打印出每个数组位置的值。

645
00:48:07,780 --> 00:48:11,330
接下来是 while 循环。while

646
00:48:11,330 --> 00:48:14,950
循环将在给定的条件语句为真时持续执行其指令。只要某个

647
00:48:14,950 --> 00:48:18,750
变量为真，只要某个数字小于另一个数字，或者只要某个值仍然

648
00:48:18,750 --> 00:48:23,260
等于另一个值，这种情况就会发生。while 循环与 for 循环不同，因为 while 循环不包含

649
00:48:23,260 --> 00:48:26,850
在一个语句中，而是延伸开来，只要条件为真，它就会持续

650
00:48:26,850 --> 00:48:28,290
运行。

651
00:48:28,290 --> 00:48:31,650
和 for 循环一样，您可以设置条件，使其最终返回 false

652
00:48:31,650 --> 00:48:35,230
并退出循环，但是，如果您创建无限循环，while 循环不会使您的

653
00:48:35,230 --> 00:48:40,290
计算机崩溃。事实上，while 循环无限运行是很常见的，因为对于

654
00:48:40,290 --> 00:48:43,770
某些程序，您希望程序不断迭代，而不是运行

655
00:48:43,770 --> 00:48:47,430
一次，直到退出程序。

656
00:48:47,430 --> 00:48:50,770
例如，在编写游戏时，可以使用 while 循环来迭代代码，

657
00:48:50,770 --> 00:48:54,710
在游戏运行时不断刷新屏幕。从那里，您可以在屏幕上

658
00:48:54,710 --> 00:48:58,100
执行操作以使游戏可玩。创建无限 while 循环只需使用语法

659
00:48:58,100 --> 00:49:02,770
while(true) 即可，因为条件 true 始终会被评估为 

660
00:49:02,770 --> 00:49:03,920
true。

661
00:49:03,920 --> 00:49:09,271
最后，我想快速介绍一下 while 循环的扩展，即 do-while 循环。Do-while

662
00:49:09,271 --> 00:49:12,400
 循环与 while 循环非常相似，

663
00:49:12,400 --> 00:49:16,210
不同之处在于它们会执行指令至少一次，即使条件为假，然后会像基本的

664
00:49:16,210 --> 00:49:20,740
循环一样继续。本质上，循环内的条件将至少运行一次，然后如果条件仍然满足，

665
00:49:20,740 --> 00:49:25,520
它们将再次运行并像普通的 while 循环一样运行。

666
00:49:25,520 --> 00:49:30,190
如您所见，循环及其多种变体具有一些

667
00:49:30,190 --> 00:49:34,240
非常有用的功能。使用它们，您可以连续多次执行操作，

668
00:49:34,240 --> 00:49:39,300
可以迭代数组和列表，并总体上减少代码的混乱。

669
00:49:39,300 --> 00:49:42,730
接下来，我们将暂时停止学习常见的编程语句，

670
00:49:42,730 --> 00:49:46,940
并深入研究当我们编写的代码不起作用时会发生什么。更具体地说，我们

671
00:49:46,940 --> 00:49:50,130
将介绍编程时可能发生的不同类型的错误

672
00:49:50,130 --> 00:49:52,300
及其原因。

673
00:49:52,300 --> 00:49:55,170
现在，当你编写代码时，你必须明白事情并不总是

674
00:49:55,170 --> 00:49:59,470
按照你预期的方式进行，有时程序并不总是按照你的预期

675
00:49:59,470 --> 00:50:04,340
运行。我们程序员称之为错误，虽然很烦人，但它们

676
00:50:04,340 --> 00:50:08,290
总是会出现在计算机科学中，所以最好了解它们是什么以及如何

677
00:50:08,290 --> 00:50:13,580
处理它们。脚本语言中的错误通常被称为“bug”，可以

678
00:50:13,580 --> 00:50:19,931
归结为三种“类型”之一：语法、运行时和逻辑，们将在今天的

679
00:50:19,931 --> 00:50:22,820
我视频中介绍这三种类型。

680
00:50:22,820 --> 00:50:27,040
首先，我们来谈谈语法错误。语法错误通常是这三种错误中

681
00:50:27,040 --> 00:50:31,960
最容易解决的，因为它们通常可以在几秒钟内修复。如果

682
00:50:31,960 --> 00:50:35,980
你还记得视频中我们之前讨论的语法和编程规则，我们说

683
00:50:35,980 --> 00:50:39,550
过如果你违反了编程规则或语法，就会导致

684
00:50:39,550 --> 00:50:44,160
错误。好吧，这就是语法错误，程序中没有

685
00:50:44,160 --> 00:50:48,850
满足编程规则的部分因此计算机不知道如何解释你的代码。

686
00:50:48,850 --> 00:50:53,210
这可能是任何事情，从忘记 Java 语句末尾的分号，到意外地

687
00:50:53,210 --> 00:50:57,340
用两个单词而不是一个单词来定义变量，甚至在尝试

688
00:50:57,340 --> 00:51:01,940
定义字符串变量时拼错了 String 一词。幸运的是，

689
00:51:01,940 --> 00:51:06,200
这些错误非常容易修复，因为您只需要找出错误发生的位置

690
00:51:06,200 --> 00:51:11,420
以及您违反的语法规则是什么。现在回想一下 IDE，我们提到 IDE

691
00:51:11,420 --> 00:51:16,580
非常有用，因为它们正是这样做的，它们会强调语法错误，

692
00:51:16,580 --> 00:51:21,490
并通常提供有关如何修复它们的有用提示。将语法错误视为您正在

693
00:51:21,490 --> 00:51:26,690
撰写的文章中的小拼写错误或语法错误，令人讨厌；是的，但不是最令人恼火的

694
00:51:26,690 --> 00:51:31,560
事情。IDE 的另一个有用之处是，

695
00:51:31,560 --> 00:51:36,320
除非清除所有语法错误，否则程序实际上会限制您运行代码，

696
00:51:36,320 --> 00:51:40,430
这使得它们更容易识别和修复。

697
00:51:40,430 --> 00:51:45,020
我们将要介绍的第二种错误是运行时错误。这些错误直到

698
00:51:45,020 --> 00:51:49,641
您实际“运行”代码时才会显示出来，因此称为“运行时”错误。运行时错误

699
00:51:49,641 --> 00:51:54,310
是由代码中的语句引起的，该语句在逻辑上似乎合理，但

700
00:51:54,310 --> 00:51:59,690
计算机实际上无法在合理的时间内计算它。

701
00:51:59,690 --> 00:52:03,780
这些错误中最常见的是我们已经讨论过的错误：无限循环。

702
00:52:03,780 --> 00:52:08,820
作为复习/示例，想象一下这样的无限循环。假设你让

703
00:52:08,820 --> 00:52:13,200
你的朋友坐在电视机前，循环播放《办公室》，并告诉他只要迈克尔说了

704
00:52:13,200 --> 00:52:17,870
“这就是她说的”这个笑话，他就可以离开了。看起来很简单吧？错了，因为

705
00:52:17,870 --> 00:52:23,190
你没有放《办公室》，而是放了《老友记》蓝光版。没有迈克尔，没有不合适的笑话，

706
00:52:23,190 --> 00:52:26,260
这意味着你的朋友将在那里坐一辈子，可能都不明白为什么邓达·米夫林看起来

707
00:52:26,260 --> 00:52:28,380
那么像一家咖啡店。这基本上就是计算机上发生的事情，你给它一些

708
00:52:28,380 --> 00:52:32,440
条件，程序必须完成这些条件才能终止；但是，你没有给它

709
00:52:32,440 --> 00:52:38,520
完成该任务的可行方法。这会使计算机处于错误模式，而且

710
00:52:38,520 --> 00:52:42,820
很可能会使程序崩溃，因为计算机会拼命地尝试完成你给它

711
00:52:42,820 --> 00:52:48,170
的条件。举一个计算机的例子，如果我们试图让程序在整数

712
00:52:48,170 --> 00:52:56,520
i 不再大于 99 时终止，但 i 最初是 100

713
00:52:56,520 --> 00:53:01,580
并且只会增加，则循环将永远不会终止，程序将崩溃。为了

714
00:53:01,580 --> 00:53:05,770
避免这些问题，你通常需要在运行代码之前仔细考虑代码流程

715
00:53:05,770 --> 00:53:10,140
- 尤其是循环 - 以确保计算机可以完成所有语句。

716
00:53:10,140 --> 00:53:14,710
在开始编写代码之前仔细规划代码是一种非常有用的做法，

717
00:53:14,710 --> 00:53:18,000
我们将在本视频的后面部分介绍这一点。

718
00:53:18,000 --> 00:53:22,240
我们将要介绍的最后一类错误是逻辑错误。这种错误也是

719
00:53:22,240 --> 00:53:27,200
不言自明的。当代码顺利运行而没有任何运行时或

720
00:53:27,200 --> 00:53:32,220
语法错误，但得到的结果却不是你想要的时，就会发生逻辑错误。例如，

721
00:53:32,220 --> 00:53:35,850
假设你有一个计算器应用程序，你想指示程序将两个数字

722
00:53:35,850 --> 00:53:40,170
相加，但由于你不小心使用了乘法符号，它反而将它们

723
00:53:40,170 --> 00:53:47,840
相乘。这导致总和为 36 而不是 13。代码语法或运行时没有出现

724
00:53:47,840 --> 00:53:53,870
任何问题，代码运行正常，只是没有按照你的预期工作。

725
00:53:53,870 --> 00:53:57,680
这些通常是最难调试的错误类型，因为大多数时候，

726
00:53:57,680 --> 00:54:02,630
您不知道为什么代码无法运行，当然也不知道如何修复它。

727
00:54:02,630 --> 00:54:06,530
这就是为什么逐步测试代码是个好主意，不要等到

728
00:54:06,530 --> 00:54:10,480
编程一个小时后才测试应用程序，否则你会

729
00:54:10,480 --> 00:54:15,520
遇到很多逻辑错误。逻辑错误可能非常令人沮丧，可能会浪费你

730
00:54:15,520 --> 00:54:19,990
很多时间，让你非常痛苦，但如果你知道如何有效地调试代码，

731
00:54:19,990 --> 00:54:23,300
那就没问题了。

732
00:54:23,300 --> 00:54:26,700
说到调试代码，这直接带我们进入下一个主题，

733
00:54:26,700 --> 00:54:28,290
即如何调试程序。

734
00:54:28,290 --> 00:54:32,040
现在，假设你已经编写了一个程序。你认为准备好了，然后你

735
00:54:32,040 --> 00:54:35,960
准备好测试一下。你一直在努力做这个，并且很激动看到它发挥作用。

736
00:54:35,960 --> 00:54:40,610
您运行程序，等待它顺利高效地运行。然而，它却不起

737
00:54:40,610 --> 00:54:43,730
作用。您遇到了我们刚才提到的三个错误之一。您确实

738
00:54:43,730 --> 00:54:47,980
希望此代码能够正常工作，但怎样？这就是调试发挥作用的地方。

739
00:54:47,980 --> 00:54:51,770
如果代码出现错误，那么您应该做的第一件事就是读取错误。

740
00:54:51,770 --> 00:54:55,450
通常，对于语法和运行时错误，IDE 会将错误消息打印到

741
00:54:55,450 --> 00:54:59,799
控制台。查看它指向哪一行或哪几行 - 因为这些行是

742
00:54:59,799 --> 00:55:05,150
发生错误的行 - 看看您是否可以理解并修复它所说的问题。如果

743
00:55:05,150 --> 00:55:09,100
错误不明确，或者您从未听说过，请尝试谷歌搜索它，有很多

744
00:55:09,100 --> 00:55:13,010
网站，例如 stackoverflow，它们可以作为询问和回答代码

745
00:55:13,010 --> 00:55:18,020
问题的论坛。如果您遇到问题，那么其他人大概也遇到过同样的问题，

746
00:55:18,020 --> 00:55:23,261
并且可能有一个经过测试的解决方案。通常，当出现语法或运行时错误时，您

747
00:55:23,261 --> 00:55:28,560
应该能够相当轻松地找到修复方法；但是，正如我之前所说，问题

748
00:55:28,560 --> 00:55:32,980
可能是由您事先没有计划的代码漏洞或疏忽引起的。

749
00:55:32,980 --> 00:55:36,440
也许你做了一些简单的事情，比如将两个变量相乘而不是相加。

750
00:55:36,440 --> 00:55:40,730
这些就是我们之前谈到的逻辑错误。这些问题通常不会出现红色文字

751
00:55:40,730 --> 00:55:45,400
来解释出了什么问题。你必须自己弄清楚。

752
00:55:45,400 --> 00:55:49,920
现在，您可以使用几种不同的策略来追踪和修复逻辑错误。

753
00:55:49,920 --> 00:55:54,550
首先，您可以使用打印语句和控制台来确定

754
00:55:54,550 --> 00:55:56,730
代码出错的位置。

755
00:55:56,730 --> 00:56:00,270
假设您有一个条件语句，如果整数 x 大于 5，则

756
00:56:00,270 --> 00:56:04,750
运行一段代码，否则运行另一段代码。

757
00:56:04,750 --> 00:56:09,700
如果在您的程序中，当程序达到此条件时 x 应该大于 5，

758
00:56:09,700 --> 00:56:13,700
但由于某种原因，程序仍然打印出“X 很小”，您可以使用打印语句

759
00:56:13,700 --> 00:56:14,700
来帮助。

760
00:56:14,700 --> 00:56:18,410
对于这个问题，你可以将上述打印语句放在

761
00:56:18,410 --> 00:56:23,010
打印 x值的条件分支之前。现在，当你运行程序时，你就

762
00:56:23,010 --> 00:56:27,650
可以确切地知道计算机在想什么。在 if/else 语句之前打印出 x

763
00:56:27,650 --> 00:56:30,921
的值将让你知道变量是否具有你想要的值，如果

764
00:56:30,921 --> 00:56:34,540
没有，你就知道在条件上方的某个地方出了问题，

765
00:56:34,540 --> 00:56:39,840
x 被设置为你不想要的值。在本例中，x 等于 2，这就是

766
00:56:39,840 --> 00:56:42,240
为什么打印出 x is small 的原因。

767
00:56:42,240 --> 00:56:46,500
现在我们知道了问题所在，我们可以追踪代码中修改

768
00:56:46,500 --> 00:56:51,540
x 的位置和时间，以找出问题所在。使用打印语句确定程序出错的位置，

769
00:56:51,540 --> 00:56:56,720
然后尝试追踪这些问题的原因并解决它们。如果您使用此策略，

770
00:56:56,720 --> 00:57:00,470
请确保最终删除打印语句，以避免控制台混乱。

771
00:57:00,470 --> 00:57:05,880
上述情况也可以使用断点来解决。当程序

772
00:57:05,880 --> 00:57:09,610
到达设置断点的行时，断点会暂停程序。

773
00:57:09,610 --> 00:57:13,300
比如说，如果您希望程序运行某个条件并根据该条件设置

774
00:57:13,300 --> 00:57:16,590
一个变量，但您不确定这在您的代码中是否真的正确

775
00:57:16,590 --> 00:57:21,630
发生，您可以在您想要运行的条件路径内放置一个断点。

776
00:57:21,630 --> 00:57:25,410
到达断点后，程序将暂停，并等待您按下按钮

777
00:57:25,410 --> 00:57:28,880
继续执行。这表示程序已到达代码中放置断点的

778
00:57:28,880 --> 00:57:34,220
位置（在本例中为正确的条件路径）。然后，

779
00:57:34,220 --> 00:57:38,230
您可以继续执行程序，同时知道代码中是否发生了

780
00:57:38,230 --> 00:57:42,510
错误。断点可以与打印语句结合使用，以便暂停

781
00:57:42,510 --> 00:57:46,890
程序，并可能查看变量当时的值，从而获得

782
00:57:46,890 --> 00:57:50,610
所需的所有信息。您还可以设置多个断点来

783
00:57:50,610 --> 00:57:56,220
帮助您慢慢执行程序并确定错误发生的位置。这

784
00:57:56,220 --> 00:57:59,460
两种策略的组合将帮助您轻松确定代码中发生

785
00:57:59,460 --> 00:58:01,230
逻辑错误的位置。

786
00:58:01,230 --> 00:58:06,280
接下来，让我们来看看，如果您认为已经找到了导致问题的

787
00:58:06,280 --> 00:58:10,330
代码段，该怎么办。您可能认为应该删除它，但您把它放在

788
00:58:10,330 --> 00:58:14,400
那里可能是有原因的，如果没有必要，您不想丢失这项工作。

789
00:58:14,400 --> 00:58:19,590
首先，尝试将其注释掉。注释用于标记代码并解释其周围

790
00:58:19,590 --> 00:58:24,370
的部分，但也可用于调试。任何被指定为注释的内容都不会被程序

791
00:58:24,370 --> 00:58:29,060
读取为代码，并且会被跳过。从本质上讲，它变成了

792
00:58:29,060 --> 00:58:34,150
只有程序员才能读取的东西。不同语言的语法各不

793
00:58:34,150 --> 00:58:37,790
相同，但通常涉及在您想要注释的代码之前或周围

794
00:58:37,790 --> 00:58:41,630
放置一些符号。现在可以在屏幕上看到如何使用不同语言进行

795
00:58:41,630 --> 00:58:46,930
注释的示例。此外，当您注释某些内容时，IDE 会将代码行

796
00:58:46,930 --> 00:58:51,991
灰度化，从而非常容易确定哪些内容被注释了，哪些内容没有被注释。注释

797
00:58:51,991 --> 00:58:56,460
代码在计算机眼中“删除”了它，但实际上并没 有删除它。如果

798
00:58:56,460 --> 00:59:00,880
在注释一段代码之前存在问题但之后问题消失了，那么那段

799
00:59:00,880 --> 00:59:04,810
代码就是罪魁祸首。如果您注释掉部分代码但仍然存在问题

800
00:59:04,810 --> 00:59:09,400
请转到另一部分，直到找到罪魁祸首。找到之后，您可以对其进行调整，

801
00:59:09,400 --> 00:59:14,000
直到它按预期工作，或者将其完全删除，这样您将再次拥有一个功能齐全的程序。

802
00:59:14,000 --> 00:59:15,580
好极了！

803
00:59:15,580 --> 00:59:19,202
既然我们已经讨论了如果遇到错误该怎么办以及如何

804
00:59:19,202 --> 00:59:23,190
查找和修复错误的策略，我想谈谈一些可以用来避免

805
00:59:23,190 --> 00:59:28,070
错误的策略。首先，经常备份代码。如果代码

806
00:59:28,070 --> 00:59:31,770
完全出错而你无法修复它，你会希望能够恢复到

807
00:59:31,770 --> 00:59:35,980
代码仍在运行的先前版本。如果你经常

808
00:59:35,980 --> 00:59:40,630
保存，那么你可能不会丢失太多工作。Github 或 

809
00:59:40,630 --> 00:59:45,261
Subversion 等版本管理器可以帮助解决这个问题，因为它们将代码备份到在线

810
00:59:45,261 --> 00:59:48,950
云服务中，你可以在任何时候轻松地从中获取程序的先前版本。

811
00:59:48,950 --> 00:59:53,700
此外，除了保存之外，还要经常运行程序以确保当前版本按预期

812
00:59:53,700 --> 00:59:58,450
工作。这样做可以实现两个目的。首先，它可以防止您保存不起作用的

813
00:59:58,450 --> 01:00:03,100
备份。其次，如果您遇到问题，如果自上次运行并运行以来

814
01:00:03,100 --> 01:00:07,220
只做了少量更改，那么将更容易找到问题，因此

815
01:00:07,220 --> 01:00:10,780
您只需查看新代码以查找问题。如果您花了 5 个小时

816
01:00:10,780 --> 01:00:14,000
编写代码，但在这段时间内没有运行过，那么很有可能

817
01:00:14,000 --> 01:00:17,731
在这 5 个小时的代码编写过程中的某个时候您搞砸了，

818
01:00:17,731 --> 01:00:21,852
而且找出错误的地方将更加困难。错误虽然令人烦恼

819
01:00:21,852 --> 01:00:25,910
和极度沮丧，但却是让您成为更好的程序员的基本部分。

820
01:00:25,910 --> 01:00:30,030
好了，现在我们已经讨论了一点错误，让我们回到编程

821
01:00:30,030 --> 01:00:35,050
语句并讨论计算机科学中最重要的概念之一，

822
01:00:35,050 --> 01:00:36,050
函数。

823
01:00:36,050 --> 01:00:39,930
现在，您可能不知道，但我们实际上在整个系列中一直在讨论一些函数。

824
01:00:39,930 --> 01:00:46,780
打印语句、for 循环，甚至基本的数学运算都是函数的例子

825
01:00:46,780 --> 01:00:51,610
这当然引出了一个问题：什么才是函数的实际定义。好吧，

826
01:00:51,610 --> 01:00:56,610
函数是一段代码，可以轻松运行“调用”函数名称

827
01:00:56,610 --> 01:01:01,060
并根据函数的类型执行相应的操作。

828
01:01:01,060 --> 01:01:07,140
函数可以在许多地方被多次调用。本质上，它们就像将一段代码包

829
01:01:07,140 --> 01:01:12,380
装成一个精美的礼物并给它起个名字；当被调用时，

830
01:01:12,380 --> 01:01:15,460
将打开礼物并查看您包装的代码。

831
01:01:15,460 --> 01:01:19,210
例如，本系列中一直使用的打印语句允许我

832
01:01:19,210 --> 01:01:25,440
们在需要时随时将某些内容打印到控制台。你看，我们只需“调用”打印函数

833
01:01:25,440 --> 01:01:31,070
并输入我们想要打印到控制台的内容，计算机就会为我们

834
01:01:31,070 --> 01:01:35,700
完成。在幕后，实际上还有更复杂的代码负责获取您的文本并将其

835
01:01:35,700 --> 01:01:40,890
翻译到控制台进行打印。几乎所有编程语言的开发

836
01:01:40,890 --> 01:01:45,390
人员都意识到，您不想通过使用复杂的编程来

837
01:01:45,390 --> 01:01:49,810
编写必须手动将某些内容打印到控制台的程序，因此他们

838
01:01:49,810 --> 01:01:54,360
实现了打印语句以减少用户的压力和代码复杂性，

839
01:01:54,360 --> 01:02:00,820
将其抽象为一行简单的代码。所有用于将某些内容打印到控制台的代码

840
01:02:00,820 --> 01:02:06,030
都被包装起来，就像一份礼物，并以一行“print()”的形式呈现给我们。

841
01:02:06,030 --> 01:02:11,701
这实际上是所有函数的主旨，也是任何优秀程序的支柱。程序中

842
01:02:11,701 --> 01:02:15,840
经常会有重复的代码段，用于相同的

843
01:02:15,840 --> 01:02:21,100
目的，或者您希望允许不同输入的方程式。因此，您可以使用函数

844
01:02:21,100 --> 01:02:26,080
将它们压缩为单行代码，以节省时间并减少代码

845
01:02:26,080 --> 01:02:31,520
的混乱。您很快就会看到，函数非常强大，并且肯定会成为

846
01:02:31,520 --> 01:02:36,960
您在计算机科学之旅中一直使用的东西。

847
01:02:36,960 --> 01:02:41,110
print 语句只是日常代码中函数的一个示例。

848
01:02:41,110 --> 01:02:45,821
IDE 中有数千个函数可供您使用。但是，

849
01:02:45,821 --> 01:02:49,920
由于您不会总是在单个程序中使用所有可用的数千个函数，

850
01:02:49,920 --> 01:02:54,790
因此您必须从 IDE 中的包中导入这些函数，我们将在后面

851
01:02:54,790 --> 01:02:55,790
介绍这一点。

852
01:02:55,790 --> 01:03:00,340
现在，大多数编程语言中有四种主要类型的函数它们由

853
01:03:00,340 --> 01:03:04,570
两个定义特征区分：是否接受参数以及

854
01:03:04,570 --> 01:03:08,970
是否返回值。让我们首先根据它们是否接受参数来区分

855
01:03:08,970 --> 01:03:13,930
它们，但首先我们必须介绍什么是参数。

856
01:03:13,930 --> 01:03:18,350
参数本质上是我们传递给函数的变量，以便进行操作

857
01:03:18,350 --> 01:03:23,910
然后返回给我们、打印到控制台或用于另一个操作。

858
01:03:23,910 --> 01:03:27,300
想象一下带有参数的函数，就像在餐厅点菜一样。如果你走到当地的快餐店，

859
01:03:27,300 --> 01:03:32,240
告诉他们你想点菜，但没有提供食物类型，

860
01:03:32,240 --> 01:03:38,010
他们可能会困惑地看着你。你需要告诉他们你想订购

861
01:03:38,010 --> 01:03:43,500
什么，以便他们可以将其交给您。在这种情况下，获取食物是函数

862
01:03:43,500 --> 01:03:49,740
而您订购的食物将作为参数传入。根据您告诉他们的内容或参数，

863
01:03:49,740 --> 01:03:56,210
他们会做一些不同的事情。您还应该注意，参数可以是许多不同的东西，

864
01:03:56,210 --> 01:04:01,740
可以是炸薯条、汉堡、苏打水，菜单上的任何食物，

865
01:04:01,740 --> 01:04:04,730
编程中的参数就是这种情况。

866
01:04:04,730 --> 01:04:14,780
这基本上就是计算机中发生的事情，例如，max 函数

867
01:04:14,780 --> 01:04:20,490
以两个整数为参数并返回两者间的最大值。现在，

868
01:04:20,490 --> 01:04:25,369
之对于此函数，如果您没有输入两个数字或变量供其比较，它将

869
01:04:25,369 --> 01:04:29,670
抛出一个错误，就像五个人的员工一样，他不知道

870
01:04:29,670 --> 01:04:33,610
你想吃什么，因为你没有向他提供任何参数，而计算机也不知道

871
01:04:33,610 --> 01:04:37,260
你想让它比较和返回哪两个数字，因为你没有向它提供

872
01:04:37,260 --> 01:04:42,720
两个整数。参数是程序员拥有一个函数的一种方式，

873
01:04:42,720 --> 01:04:47,730
该函数可以根据可以传递的变量执行许多不同的操作。参数增加了

874
01:04:47,730 --> 01:04:52,330
编程的可变性，并有助于使代码多样化。回想一下我们五个人的例子，

875
01:04:52,330 --> 01:04:56,510
一家餐厅只允许制作一种食物，而不管你点什么，

876
01:04:56,510 --> 01:05:01,780
这都不会非常有用或多样化，但如果我们能够传递参数并告诉他们

877
01:05:01,780 --> 01:05:06,310
我们想要什么食物，我们的体验就会得到提升，并且有更多的选择，

878
01:05:06,310 --> 01:05:12,530
这正是您在函数中接受参数时所发生的事情。

879
01:05:12,530 --> 01:05:16,170
现在我们已经讨论了接受参数的函数，让我们继续讨论

880
01:05:16,170 --> 01:05:20,710
不接受参数的函数，因为函数也可以在不接受参数的情

881
01:05:20,710 --> 01:05:25,870
况下创建和使用，并且仍然非常有用。例如，假设您正在制作一款

882
01:05:25,870 --> 01:05:30,380
基于文本的 RPG 游戏，您为玩家提供的选项之一是能够在整个

883
01:05:30,380 --> 01:05:35,260
游戏过程中查看玩家的统计数据。现在，每次您遇到一个选项

884
01:05:35,260 --> 01:05:39,660
并且他们选择“查看统计数据”按钮时，您都不想为每个统计数据输入 6

885
01:05:39,660 --> 01:05:43,520
个不同的打印语句，否则您的代码很快就会变得杂乱

886
01:05:43,520 --> 01:05:49,210
无章。相反，您可以做的是将 6 个不同的打印语句打包在一个

887
01:05:49,210 --> 01:05:54,150
名为 printStats() 的简单函数中。您不需要向函数传递

888
01:05:54,150 --> 01:05:58,260
任何参数，因为无论玩家的统计数据如何，函数都会执行

889
01:05:58,260 --> 01:06:04,310
相同的操作。现在，每次用户想要查看他们的统计数据时，你只需调用 printStats()

890
01:06:04,310 --> 01:06:09,531
函数，然后，用户的统计数据就会被打印出来供他们查看。这不仅能

891
01:06:09,531 --> 01:06:14,290
让你节省大量编写代码的时间，还能节省大量空间，

892
01:06:14,290 --> 01:06:19,360
当你的程序开始达到数百和数千行并且你想轻松地搜索它时，

893
01:06:19,360 --> 01:06:21,390
这一点非常重要。

894
01:06:21,390 --> 01:06:26,410
好的，现在我们已经将函数分为接受参数的函数和不接受参数的

895
01:06:26,410 --> 01:06:31,850
函数，让我们再次将它们分为返回值的函数和不返回值的函数。

896
01:06:31,850 --> 01:06:35,790
现在你需要了解的是，当你创建自己的函数时（我们

897
01:06:35,790 --> 01:06:40,660
很快就会讲到），你必须选择函数要返回什么

898
01:06:40,660 --> 01:06:46,010
（如果有的话）。函数能够将值返回给用户，无论是

899
01:06:46,010 --> 01:06:53,150
字符串变量、整数变量还是数组。现在需要注意的是，

900
01:06:53,150 --> 01:06:57,760
单独调用函数不会产生任何效果。你必须将值返回到

901
01:06:57,760 --> 01:07:04,230
某个对象中。例如，我们之前讨论过的 Max 函数会

902
01:07:04,230 --> 01:07:10,280
返回一个整数，但为了用它做某事，我们必须设置一个

903
01:07:10,280 --> 01:07:15,610
等于该 Max 函数结果的新整数变量，或者我们可以打印出

904
01:07:15,610 --> 01:07:19,640
函数的结果，在这种情况下，只会打印出两个整数之间的

905
01:07:19,640 --> 01:07:24,720
最大值。使用返回值的函数本身并没有多大用处，你必须

906
01:07:24,720 --> 01:07:28,080
将它与某个对象配对才能使用它。

907
01:07:28,080 --> 01:07:32,570
让我们再举一个例子，假设你创建了一个函数，它接受两个字符串

908
01:07:32,570 --> 01:07:38,530
变量作为参数，使用我们之前讨论过的花哨的字符串数学将它们组合起来，

909
01:07:38,530 --> 01:07:43,460
然后将它们作为单个字符串返回。然后可以使用此 CombineString 函数

910
01:07:43,460 --> 01:07:49,260
来创建新的字符串变量，因为从技术上讲，它返回的是一个字符串。

911
01:07:49,260 --> 01:07:55,260
该变量将被简单地设置为从 CombineString 返回的任何内容。

912
01:07:55,260 --> 01:07:59,480
最后一种函数不返回任何内容的那种，称为

913
01:07:59,480 --> 01:08:05,240
“void”函数。通常，这些函数类似于我们之前创建的 printStats 函数，

914
01:08:05,240 --> 01:08:10,270
仅用于压缩代码中经常出现的大量打印语句。

915
01:08:10,270 --> 01:08:15,100
这些不能设置为变量，因为它们不返回任何东西，只是

916
01:08:15,100 --> 01:08:17,500
运行其中的代码。

917
01:08:17,500 --> 01:08:23,070
这就是 4 种类型的功能。有的接受参数并返回值，

918
01:08:23,070 --> 01:08:27,390
有的接受参数但不返回值，有的不接受参数

919
01:08:27,390 --> 01:08:32,640
但仍返回值，还有的接受参数但不返回任何值。

920
01:08:32,640 --> 01:08:37,180
这 4 种类型的函数各有其用途和独特之处，您可能会

921
01:08:37,180 --> 01:08:41,589
在整个编程过程中发现自己都在使用它们，因此请习惯不同

922
01:08:41,589 --> 01:08:46,180
类型的函数并知道如何充分利用它们，因为它们都非常强大。

923
01:08:46,180 --> 01:08:50,839
最后，我想谈谈函数的一个主要优点，那就是它

924
01:08:50,839 --> 01:08:55,000
对代码进行大量更改非常实用，而无需浏览整个

925
01:08:55,000 --> 01:09:01,859
程序。每个函数调用都只是该函数原始代码的副本，

926
01:09:01,859 --> 01:09:06,259
因此可以非常轻松地更改函数并将其转换为整个

927
01:09:06,259 --> 01:09:11,380
代码。让我们回到我们的 printStats() 函数，假设您想返回

928
01:09:11,380 --> 01:09:17,690
并添加一个新统计数据，玩家可以通过游戏中的经验升级。如果

929
01:09:17,690 --> 01:09:21,290
没有函数，您将不得不返回代码，找到打印出用户统计数据

930
01:09:21,290 --> 01:09:26,150
的每个实例，并创建另一个打印语句来显示新统计数据。

931
01:09:26,150 --> 01:09:31,730
但是，如果您像我们之前所做的那样创建了 printStats() 函数，

932
01:09:31,730 --> 01:09:36,339
那么您需要做的就是找到定义该函数的位置并添加显示新统计数据的

933
01:09:36,339 --> 01:09:42,020
print 语句，然后就大功告成了。现在，每个之前调用过

934
01:09:42,020 --> 01:09:47,060
printStats 函数的地方也将打印新的统计数据。您

935
01:09:47,060 --> 01:09:51,850
可以看到，如果使用得当，函数可以有多么强大，而我们甚至还没有

936
01:09:51,850 --> 01:09:53,420
触及皮毛。

937
01:09:53,420 --> 01:09:57,350
现在，接下来我们将介绍如何导入其他人

938
01:09:57,350 --> 01:10:00,020
编写的函数并在我们的代码中使用它们。

939
01:10:00,020 --> 01:10:04,300
在我们讨论技术问题之前，请闭上眼睛，想象您正在建造一座房子。

940
01:10:04,300 --> 01:10:09,390
当然，你可以自己种树、砍伐木材、制作工具和

941
01:10:09,390 --> 01:10:13,730
钉子，然后从头开始建造。但为什么要这样做呢？你可以简单地去当地的

942
01:10:13,730 --> 01:10:17,760
家得宝（Home Depot）购买其他人已经为你准备好的材料。这

943
01:10:17,760 --> 01:10:22,171
就是将函数导入代码背后的主要思想。导入函数使你

944
01:10:22,171 --> 01:10:26,750
可以访问其他人已经为你制作的函数库。这

945
01:10:26,750 --> 01:10:31,380
听起来很有用。对于任何给定的程序来说，有许多非

946
01:10:31,380 --> 01:10:36,350
常有用的函数，以至于你自己编写它们将花费你很长时间。幸运的是，

947
01:10:36,350 --> 01:10:38,920
其他人已经为你完成了大部分工作。

948
01:10:38,920 --> 01:10:43,250
在每种编程语言中，您都可以使用 import 语句将函数库

949
01:10:43,250 --> 01:10:46,610
导入到您的程序中，以便在编写程序时使用。

950
01:10:46,610 --> 01:10:51,670
库（library）只是具有相同主题的函数的集合。它可能是一个

951
01:10:51,670 --> 01:10:56,920
数学库、一个数据分析库、一个文本翻译库，或者任何你

952
01:10:56,920 --> 01:11:01,480
能想到的东西。任何给定语言都有各种各样的库，以至于

953
01:11:01,480 --> 01:11:06,090
你需要的大多数不是特定于你的程序的函数都可能在某个库中

954
01:11:06,090 --> 01:11:11,650
找到。事实上，任何程序员工作的很大一部分都是在网上寻找可以

955
01:11:11,650 --> 01:11:17,770
简化他或她的工作的包，而不是手写函数。现在，我可以听到你说，“哇，

956
01:11:17,770 --> 01:11:23,440
这太酷了，我该怎么做？” 嗯，这很简单：一个 import 语句。

957
01:11:23,440 --> 01:11:28,350
在大多数语言中，导入语句由 3 部分组成。您要从中

958
01:11:28,350 --> 01:11:33,130
导入的库、您要从该库中导入的包，以及您

959
01:11:33,130 --> 01:11:38,520
要使用该包中的哪个类。例如，我们可以加载 Java 库，

960
01:11:38,520 --> 01:11:43,560
然后从那里导入 util 包（实用程序的简称），然后从该实用

961
01:11:43,560 --> 01:11:48,230
程序包导入扫描仪（scanner）类，该类允许我们从用户那里

962
01:11:48,230 --> 01:11:52,770
读取信息。包（package）只是一小部分函数和方法，用于帮助区分

963
01:11:52,770 --> 01:11:57,730
库中包含的数千种方法，而类（class）甚至比这更

964
01:11:57,730 --> 01:11:59,380
专业。

965
01:11:59,380 --> 01:12:04,110
现在，如果您不知道要从哪些特定类中提取方法，

966
01:12:04,110 --> 01:12:08,710
则可以使用星号（ * ）导入您想要的包中的所有类。但是，

967
01:12:08,710 --> 01:12:12,700
更具体一点，只导入您想要的类会更有好处，

968
01:12:12,700 --> 01:12:18,380
因为从长远来看，这有助于提高程序的效率。例如，在 Python 中，

969
01:12:18,380 --> 01:12:24,140
导入库的语法是 import 后跟库名称。但是，导入

970
01:12:24,140 --> 01:12:31,060
整个库比从库中导入特定函数的计算量更大。

971
01:12:31,060 --> 01:12:35,110
想象一下，您只会使用 Python 数学库中的阶乘函数。

972
01:12:35,110 --> 01:12:39,060
导入整个库会浪费计算能力，并会增加

973
01:12:39,060 --> 01:12:43,850
程序的加载时间。对于较小的程序来说，这不是什么大问题，但在

974
01:12:43,850 --> 01:12:48,041
处理较大的项目时，它确实开始累积起来。因此，您改为

975
01:12:48,041 --> 01:12:55,210
使用 “from math import factorial” 或 java 等效的
“import java.math.factorial”，

976
01:12:55,210 --> 01:12:59,489
现在只能访问该 math 命令。这限制了您可以使用的

977
01:12:59,489 --> 01:13:03,960
函数，但它节省了编程运行时间。如果您决定要使用其他

978
01:13:03,960 --> 01:13:09,120
未计划的功能，您可以随时返回并导入该功能。很多时候，如果

979
01:13:09,120 --> 01:13:13,020
您尝试使用来自通用包的函数但尚未导入它，

980
01:13:13,020 --> 01:13:15,310
IDE 会提示您这样做。

981
01:13:15,310 --> 01:13:19,190
如果您想知道要导入哪些库，请考虑

982
01:13:19,190 --> 01:13:23,910
程序中需要的函数。执行简单的 Google 搜索，您可能会找到

983
01:13:23,910 --> 01:13:29,390
IDE 中已存在的可用包或库。如果

984
01:13:29,390 --> 01:13:34,330
您找不到，可以通过多种方式下载和导入其他项目以满足您的需求。

985
01:13:34,330 --> 01:13:38,830
但是如果经过所有这些操作后，你仍然找不到包含所需

986
01:13:38,830 --> 01:13:42,760
函数的库？那么，这正好引出了我们接下来要讨论的

987
01:13:42,760 --> 01:13:47,750
内容，即编写自己的函数的基本结构。

988
01:13:47,750 --> 01:13:51,290
到目前为止，我们已经讨论了什么是函数以及如何通过

989
01:13:51,290 --> 01:13:55,040
包导入函数来获得一些非常有用的函数。但是在你的

990
01:13:55,040 --> 01:13:58,340
编程旅程中肯定会有一些时刻，你会想要创建自己的函数，

991
01:13:58,340 --> 01:14:04,440
因为你想创建一个特定于你的程序和代码的函数。幸运的是，

992
01:14:04,440 --> 01:14:08,570
创建自己的函数非常简单，我只想介绍一些基本

993
01:14:08,570 --> 01:14:14,440
规则。虽然我们之前曾以创建函数作为其他主题的示例，例如

994
01:14:14,440 --> 01:14:18,830
不久前的 playerStats 函数，但它们非常抽象，

995
01:14:18,830 --> 01:14:23,070
并没有深入探讨实际函数运行所需的内容。所以现在

996
01:14:23,070 --> 01:14:26,860
我们将介绍一个框架系统，其中包含使函数

997
01:14:26,860 --> 01:14:30,190
正常工作所需的所有内容。

998
01:14:30,190 --> 01:14:34,420
现在回想一下我们之前讨论过的 4 种不同类型的功能。

999
01:14:34,420 --> 01:14:38,080
返回值和不返回值的函数，以及接受和不接受

1000
01:14:38,080 --> 01:14:42,540
参数的函数。对于创建自己的函数，我们将逐一介绍

1001
01:14:42,540 --> 01:14:47,690
如何创建它们，从最基本的函数开始，

1002
01:14:47,690 --> 01:14:53,670
即不接受参数也不返回值的函数，但在开始之前，我想

1003
01:14:53,670 --> 01:14:58,690
先说几件关于函数命名约定的小事。我们之前讨论过的

1004
01:14:58,690 --> 01:15:03,440
变量命名约定也适用于函数名。因此，不能有

1005
01:15:03,440 --> 01:15:08,611
两个单词的函数，也不能使用句点或逗号等特殊字符。通常，

1006
01:15:08,611 --> 01:15:12,400
您需要遵循我们在变量视频中讨论过的相同的驼峰式

1007
01:15:12,400 --> 01:15:16,340
命名风格。

1008
01:15:16,340 --> 01:15:23,730
好吧，一般来说，对于创建函数，每种语言都会区分如何告诉

1009
01:15:23,730 --> 01:15:29,340
计算机它是一个函数。在 Java 中，你必须定义函数范围，

1010
01:15:29,340 --> 01:15:32,780
除非你打算更多地研究 Java，否则你实际上不需要知道这

1011
01:15:32,780 --> 01:15:38,130
一点，但基本上它会告诉计算机哪些部分的代码可以使用该函数，

1012
01:15:38,130 --> 01:15:43,790
哪些类型不能使用。对于本系列，我们所有的函数都将是公共的。然后，

1013
01:15:43,790 --> 01:15:48,230
你再从那里确定它是哪种类型的函数，所以在这种情况下，

1014
01:15:48,230 --> 01:15:52,481
由于它不会返回任何变量，我们只需放置 void 来表示这种类型的函数不会

1015
01:15:52,481 --> 01:15:57,820
返回任何内容。最后，将函数名称放在这两个标识符

1016
01:15:57,820 --> 01:16:02,380
并在其后加上一组括号，如下所示。如果你要创建一个接受参数的函数，

1017
01:16:02,380 --> 01:16:06,630
那么括号就是你的参数所在的位置，但是由于对于我们的第一种

1018
01:16:06,630 --> 01:16:11,050
类型的函数，我们不会将参数合并到这个函数中，所以我们就把它

1019
01:16:11,050 --> 01:16:17,710
留空吧。所有这些都仅适用于 Java；另一方面，在 Python 中，

1020
01:16:17,710 --> 01:16:23,420
你只需输入 def（define 的缩写），然后输入带有括号的函数名称。如你

1021
01:16:23,420 --> 01:16:29,000
所见，每种语言都会有所不同，但我们要记住的主要事情是

1022
01:16:29,000 --> 01:16:34,420
始终添加括号。从那里，我们只需在函数范围内输入我们希望 void

1023
01:16:34,420 --> 01:16:38,700
函数执行的操作，然后关闭循环，我们就完成了，

1024
01:16:38,700 --> 01:16:42,400
轻而易举。在 Java 中，循环的范围是花括号内包含的

1025
01:16:42,400 --> 01:16:47,980
任何内容，而在 python 中，它将一直持续到不再缩进为止。从本质上讲，

1026
01:16:47,980 --> 01:16:51,520
这是我们刚刚创建的最原始的函数类型。它不接受任何参数，

1027
01:16:51,520 --> 01:16:56,420
也不返回任何值，与之前的 printStats 函数非常

1028
01:16:56,420 --> 01:16:58,370
相似。

1029
01:16:58,370 --> 01:17:03,080
接下来介绍下一种函数，创建一个接受参数的 void 函数。

1030
01:17:03,080 --> 01:17:08,370
现在这个过程看起来与上一个过程非常相似，除了一个小小的调整。

1031
01:17:08,370 --> 01:17:12,420
还记得我 30 秒前提到的括号吗？我们将希望

1032
01:17:12,420 --> 01:17:17,610
用户传递到函数中的任何变量都放在这些括号中，然后当我们“调用”

1033
01:17:17,610 --> 01:17:22,791
该特定函数时，就需要将这些变量传递给它。例如，

1034
01:17:22,791 --> 01:17:26,980
在 Java 中，让我们创建一个函数，该函数接受 2 个数字并打印出

1035
01:17:26,980 --> 01:17:32,360
这些数字的乘积。我们从 public void 加上函数设置的名称开始，因为

1036
01:17:32,360 --> 01:17:37,770
我们不会返回任何值。现在到了新的部分。在括号内，

1037
01:17:37,770 --> 01:17:43,530
你定义要作为参数传入的变量类型，在本例中是一个整数，

1038
01:17:43,530 --> 01:17:48,210
然后为该变量命名。此名称是您将用来引用用户传入的整数的名称。

1039
01:17:48,210 --> 01:17:54,000
对于此示例，我们将其称为 num1。然后，如果我们想添加另一个参数，

1040
01:17:54,000 --> 01:17:58,570
我们只需在两者之间添加一个逗号，就可以创建另一个

1041
01:17:58,570 --> 01:18:03,840
整数变量 num2 来保存第二个数字。我们可以对想要传入函数的

1042
01:18:03,840 --> 01:18:08,190
任意多个变量执行此操作，但现在让我们关闭括号并只打印

1043
01:18:08,190 --> 01:18:14,280
num1 和 num2 的乘积。如您所见，我们将用户将输入到函数的

1044
01:18:14,280 --> 01:18:19,720
两个数字称为 num1 和 num2。

1045
01:18:19,720 --> 01:18:29,400
现在，无论何时我们想要调用 multiplyNumbers 函数，

1046
01:18:29,400 --> 01:18:34,570
我们只需确保输入 2 个数字作为参数。在本例中，数字 5 变为 num1，

1047
01:18:34,570 --> 01:18:39,880
数字 8 变为 num2。从那里我们只需运行代码，数字 40 就会

1048
01:18:39,880 --> 01:18:44,590
打印到控制台。值得注意的是，在创建参数时，您还可以混合和

1049
01:18:44,590 --> 01:18:50,500
匹配变量。因此，您可以在一个函数中拥有一些函数，它接受一个字符、一个整数和两个

1050
01:18:50,500 --> 01:18:54,140
字符串。在我看来非常简洁。关于参数我最后要说的是

1051
01:18:54,140 --> 01:18:58,780
当您调用一个函数时，您必须遵循在创建函数时。

1052
01:18:58,780 --> 01:19:03,680
定义的变量因此，对于我们的 multiplyNumbers 函数，您不能先输入一个字符串，

1053
01:19:03,680 --> 01:19:08,400
然后再输入一个整数。它必须是两个整数，因为这是计算机期望

1054
01:19:08,400 --> 01:19:11,310
传递给函数的。

1055
01:19:11,310 --> 01:19:14,710
现在我们已经了解了如何制作不返回变量的函数，我们

1056
01:19:14,710 --> 01:19:18,630
必须介绍那些返回变量的函数，我们将从不接受参数的函数开始。

1057
01:19:18,630 --> 01:19:23,420
现在，定义返回变量的函数和定义不返回变量的函数之间的主要区

1058
01:19:23,420 --> 01:19:29,060
别在于，在某些情况下，您必须指定希望此函数返回一个整数

1059
01:19:29,060 --> 01:19:34,100
变量，这在 Java 中最常用，您将用“int”替换“void”，

1060
01:19:34,100 --> 01:19:38,210
以告诉计算机您希望此函数以整数形式返回

1061
01:19:38,210 --> 01:19:44,070
一些值。这与您希望返回字符串、字符甚至

1062
01:19:44,070 --> 01:19:49,460
数组一样。您只需将 public 后面的单词替换为您希望函数返回的

1063
01:19:49,460 --> 01:19:51,330
任何变量即可。

1064
01:19:51,330 --> 01:19:55,330
在制作返回变量的函数时要记住的最重要的事情是，无论

1065
01:19:55,330 --> 01:19:59,881
代码采用什么路径，它都*必须*返回一个变量，无论如何。

1066
01:19:59,881 --> 01:20:05,250
这是什么意思？好吧，假设您在游戏中有一些字符串函数，

1067
01:20:05,250 --> 01:20:09,440
其中有一个 if 语句，如果玩家得分高于 10，

1068
01:20:09,440 --> 01:20:14,250
则返回一条祝贺消息。如果您打印此函数的结果并且玩家的得分

1069
01:20:14,250 --> 01:20:18,920
高于 10，则此方法可以正常工作。但是，如果 playerScore 小于 10，

1070
01:20:18,920 --> 01:20:22,220
则您不会进入 if 语句，然后您没有准备好返回给用户的

1071
01:20:22,220 --> 01:20:26,969
内容，因此该函数将抛出错误。您*必须*覆盖所有路径，

1072
01:20:26,969 --> 01:20:31,340
这看似简单，但如果您创建的函数中包含包含大量

1073
01:20:31,340 --> 01:20:36,840
案例的 switch 语句，则很快就会失控。为了确保

1074
01:20:36,840 --> 01:20:40,540
不会发生这种情况，我喜欢在函数底部放置一个 return 语句，

1075
01:20:40,540 --> 01:20:44,760
其中包含一个字符串或整数，这些字符串或整数是如此独特，以至于我能够判断代码

1076
01:20:44,760 --> 01:20:57,650
运行不正常并可以修复它。然而，我想要表达的重点是，

1077
01:20:57,650 --> 01:21:02,170
始终覆盖你的出口，并且始终为用户可能遇到的任何情况

1078
01:21:02,170 --> 01:21:03,960
准备好返回语句。

1079
01:21:03,960 --> 01:21:07,870
需要注意的另一件小事是，如果您已经定义了函数返回另一种类型，

1080
01:21:07,870 --> 01:21:12,660
那么您就不能返回一种类型的变量。例如，你不能在整数函数中

1081
01:21:12,660 --> 01:21:17,969
返回字符串，反之亦然。无论如何，返回语句必须始终与函数类型

1082
01:21:17,969 --> 01:21:19,520
匹配。

1083
01:21:19,520 --> 01:21:24,239
最后一种函数类型是返回变量并接受参数的函数，

1084
01:21:24,239 --> 01:21:28,390
对于这些函数，您需要做的就是结合我们从前面的案例中学到的知识。首先，

1085
01:21:28,390 --> 01:21:33,770
在括号中分配参数，确保您还定义了要返回的

1086
01:21:33,770 --> 01:21:38,960
变量，然后确保无论代码采用哪种路径，您始终

1087
01:21:38,960 --> 01:21:44,271
返回该变量类型。这就是我们对函数的讨论。您

1088
01:21:44,271 --> 01:21:48,770
可能已经发现，函数是一个非常广泛的主题领域，需要一点

1089
01:21:48,770 --> 01:21:53,630
练习才能完全理解，这就是为什么我们稍后会推荐一些

1090
01:21:53,630 --> 01:21:58,790
可用于练习这些更困难主题的网站。

1091
01:21:58,790 --> 01:22:03,010
现在我想稍微转换一下话题，继续我们之前关于数组的讨

1092
01:22:03,010 --> 01:22:09,810
论。数组虽然有用，但并不是存储和操作信息的唯一方法。

1093
01:22:09,810 --> 01:22:14,790
事实上，计算机科学中有很多种存储数据的方式，包括 

1094
01:22:14,790 --> 01:22:21,260
LinkedLists、Stacks、Queue、Maps、Trees 等等。

1095
01:22:21,260 --> 01:22:26,680
不过现在，我想谈谈我们之前没有涉及过的两种酷炫、

1096
01:22:26,680 --> 01:22:32,320
古怪和滑稽的数据存储方式：ArrayList 和字典。但在讨论这些之前，

1097
01:22:32,320 --> 01:22:35,910
让我们先回顾/强化一下数组。

1098
01:22:35,910 --> 01:22:40,580
您可能还记得，数组基本上是存储在一起的值的列表。

1099
01:22:40,580 --> 01:22:45,310
初始化数组时，会为其指定一个大小，并且该大小是固定的。您无法

1100
01:22:45,310 --> 01:22:48,630
增加数组的大小，因此在创建数组时，其长度是

1101
01:22:48,630 --> 01:22:54,350
固定的。要访问数组中的值，可以使用从 0 开始的索引来

1102
01:22:54,350 --> 01:23:00,489
引用它们。这意味着数组的第一项不在位置1，而是在

1103
01:23:00,489 --> 01:23:06,010
位置0，其位置通常称为索引位置。因此，

1104
01:23:06,010 --> 01:23:12,720
要查找数组中的第 n 项，可以将其称为索引位置[n-1]。但是，

1105
01:23:12,720 --> 01:23:16,310
由于数组的大小是固定的，因此必须注意不要引用

1106
01:23:16,310 --> 01:23:21,560
超出数组总大小的位置，也不要向其附加太多项，因为

1107
01:23:21,560 --> 01:23:26,110
这将返回错误。我们还有所谓的二维数组，

1108
01:23:26,110 --> 01:23:30,700
即在其每个索引处都包含一个数组的数组。或者，您可以有一个数组，

1109
01:23:30,700 --> 01:23:34,880
其中包含包含数组的数组，其中包含包含数组的数组，这取决于

1110
01:23:34,880 --> 01:23:39,070
您要执行的操作。多维数组在更高级的程序中

1111
01:23:39,070 --> 01:23:44,120
可用于组织大量相关值。如果这让您感到困惑，请跳回前面，查看 

1112
01:23:44,120 --> 01:23:48,950
我们对 Array 的完整讨论，时间戳将在描述中。

1113
01:23:48,950 --> 01:23:53,920
我们已经回顾了数组，现在让我们回顾一下数组列表。数组列表（在

1114
01:23:53,920 --> 01:23:57,230
Python 中简称为列表）可以被认为是一个不断增长的数组。

1115
01:23:57,230 --> 01:24:01,860
前面我们提到了如何小心地设置适当的数组大小，

1116
01:24:01,860 --> 01:24:06,450
并确保仅引用和附加值以保持在数组大小之内。

1117
01:24:06,450 --> 01:24:11,670
但是，对于数组列表，这不是问题。初始化 arrayList 后，

1118
01:24:11,670 --> 01:24:16,760
它的大小本能地为10，但是如果您附加值，使得 arrayList

1119
01:24:16,760 --> 01:24:21,650
的大小超过 10 个元素，arrayList会“增长”，这意味着

1120
01:24:21,650 --> 01:24:25,940
计算机将为数组分配更多内存以增加其总大小，

1121
01:24:25,940 --> 01:24:29,960
以便可以附加新值。当您不知道数组需要存

1122
01:24:29,960 --> 01:24:34,800
储的确切值数量，或者想要随心所欲地存储值时，

1123
01:24:34,800 --> 01:24:38,810
这非常有用，例如创建一个包含未知数量的将注册用户的

1124
01:24:38,810 --> 01:24:40,280
数据库。

1125
01:24:40,280 --> 01:24:44,450
关于 arrayLists ，还有很多内容需要揭示，但是对于这个表面级别的系列，

1126
01:24:44,450 --> 01:24:48,840
这些就是你需要知道的全部内容，因此让我们继续讨论字典。

1127
01:24:48,840 --> 01:24:52,739
现在，当我们谈论字典时，我们指的并不是你家里可能有

1128
01:24:52,739 --> 01:24:57,739
的那本厚书，里面有成千上万个定义。在计算机科学中，

1129
01:24:57,739 --> 01:25:02,340
字典就像数组，它们存储多个值，但它们的值的存储方式非常不同。

1130
01:25:02,340 --> 01:25:06,360
每个值不是通过它们在字典中的位置线性引用，

1131
01:25:06,360 --> 01:25:10,981
而是与用于引用它的另一个值或它的“键”相关联。

1132
01:25:10,981 --> 01:25:15,250
因此，我们需要抛弃所有将字典视为线性数据查看方式的概念，

1133
01:25:15,250 --> 01:25:21,469
因为实际上它更加流畅和可互换。基本上，

1134
01:25:21,469 --> 01:25:26,590
我们说字典中的每个位置都包含一个键/值对。引用字典中的值时，

1135
01:25:26,590 --> 01:25:31,190
您将使用它的唯一键，字典将告诉您与之绑定的值。

1136
01:25:31,190 --> 01:25:36,060
可以这样想，每次您将一个项目添加到字典中时，

1137
01:25:36,060 --> 01:25:40,870
您的计算机都会创建一个手工制作的盒子来存储数据，

1138
01:25:40,870 --> 01:25:46,390
还会定制一把镶有宝石的钥匙，独一无二，世界上没有其他钥匙。

1139
01:25:46,390 --> 01:25:51,550
这样，只有一个钥匙可以进入存储特定信息的盒子。由于每个键必须是唯一的，

1140
01:25:51,550 --> 01:25:55,430
因此在字典中重复使用键会导致抛出错误，因为

1141
01:25:55,430 --> 01:26:00,739
两个完全相同的键会让计算机无法判断该键指向哪个盒子或

1142
01:26:00,739 --> 01:26:05,860
信息位。但是，您可以将相同的值存储在多个键/值对中，

1143
01:26:05,860 --> 01:26:08,400
因为键都是不同的。

1144
01:26:08,400 --> 01:26:13,040
现在，就像我说的，字典更加灵活，这使得它们比数组更容易组织，

1145
01:26:13,040 --> 01:26:17,980
因为一切都以更合乎逻辑的方式设置。也就是说，

1146
01:26:17,980 --> 01:26:22,330
当你使用键而不是简单地引用它们的位置时，更容易找到

1147
01:26:22,330 --> 01:26:27,230
你要找的值。让我解释一下我的意思。假设你有一本商店价格词典，

1148
01:26:27,230 --> 01:26:31,670
其中的键是产品名称，值是商品的价格。苹果可能

1149
01:26:31,670 --> 01:26:36,790
售价 1 美元，牛奶售价 2 美元，面包售价 3 美元。您可以看到，

1150
01:26:36,790 --> 01:26:41,520
在字典中，每个键都是产品名称，每个键对应

1151
01:26:41,520 --> 01:26:45,590
每种产品的价格。因此，要查找面包的价格，您只需

1152
01:26:45,590 --> 01:26:48,390
使用键“面包”调用字典，字典就会返回值

1153
01:26:48,390 --> 01:26:51,960
1。这使得通过代码跟踪值变得非常容易，因为您

1154
01:26:51,960 --> 01:26:55,840
处理的是有形值，而不是对您没有任何意义的数字。

1155
01:26:55,840 --> 01:27:00,280
您还可以使用与操作数组和数组列表相同的方式

1156
01:27:00,280 --> 01:27:04,610
操作字典。您可以遍历字典并对值执行许多操作和比较。

1157
01:27:04,610 --> 01:27:09,170
例如，如果您想找到价格最高的产品，您可以

1158
01:27:09,170 --> 01:27:12,820
遍历字典以找到杂货店商品中

1159
01:27:12,820 --> 01:27:13,910
价格最高的产品。

1160
01:27:13,910 --> 01:27:18,800
数组、数组列表和字典本身就很有用，还有大量其他存储

1161
01:27:18,800 --> 01:27:23,940
数据的方法，每种方法都具有某些优势。

1162
01:27:23,940 --> 01:27:28,420
我们已经介绍了 3 种方法的基础知识，但由于方法太多，

1163
01:27:28,420 --> 01:27:32,330
我们没有时间深入介绍每种方法，因此，为了帮助您

1164
01:27:32,330 --> 01:27:35,550
掌握存储信息的基础知识，我们现在将讨论理

1165
01:27:35,550 --> 01:27:38,770
解数组所需的最重要的函数之一，即搜索算法。

1166
01:27:38,770 --> 01:27:43,130
现在，就像计算机科学中存储信息的方法有很多种一样，通过

1167
01:27:43,130 --> 01:27:47,680
列表进行搜索的方法也有很多种。搜索算法的核心是，

1168
01:27:47,680 --> 01:27:52,040
我们可以查看存储在数组中的值列表，例如患者姓名列表

1169
01:27:52,040 --> 01:27:57,590
或高分列表，并找到特定的数据。搜索算法的目标

1170
01:27:57,590 --> 01:28:02,300
只是为算法提供一个您希望它找到的字符串或对象，并尽快返回

1171
01:28:02,300 --> 01:28:07,880
包含该字符串或对象的数组的索引。现在这似乎很简单，

1172
01:28:07,880 --> 01:28:11,750
但许多软件都以能够极快地搜索列表为基础运行，

1173
01:28:11,750 --> 01:28:17,300
这使得搜索算法（特别是高效的搜索算法）成为

1174
01:28:17,300 --> 01:28:22,520
一个重要的主题。此外，这是数组的主要功能，

1175
01:28:22,520 --> 01:28:27,390
也是 arrayLists 中使用的许多方法以及许多其他

1176
01:28:27,390 --> 01:28:32,450
存储方法的基础，因此了解它们将对您大有裨益。

1177
01:28:32,450 --> 01:28:36,910
通常，搜索算法用于返回特定数据点的索引，

1178
01:28:36,910 --> 01:28:42,280
以便可以使用、修改、更新或检查它。例如，如果您即将

1179
01:28:42,280 --> 01:28:46,910
入住一家使用数组系统为患者服务的医院，工作人员必须在

1180
01:28:46,910 --> 01:28:51,070
数据库中搜索您的姓名，通过返回您的姓名所在位置的索引，他们现在有

1181
01:28:51,070 --> 01:28:56,050
一个可量化的数字，他们可以使用这个数字轻松地为您办理入住手续、出租处方、

1182
01:28:56,050 --> 01:29:00,510
安排您的检查、更新您的个人信息等，而不必每次都

1183
01:29:00,510 --> 01:29:03,900
搜索列表中的姓名。

1184
01:29:03,900 --> 01:29:07,420
您可能认为搜索算法之间没有什么区别，因为如今的计算机每秒

1185
01:29:07,420 --> 01:29:12,420
可以执行数百万次计算，但当您是一家价值数十亿美元的大型公司

1186
01:29:12,420 --> 01:29:16,739
试图在包含数千甚至数百万个数据点的列表中找到

1187
01:29:16,739 --> 01:29:21,860
某个数据点时，效率上的微小差异就会决定用户体验

1188
01:29:21,860 --> 01:29:27,070
的好坏。即使效率提高 1%，也可能意味着用户

1189
01:29:27,070 --> 01:29:30,969
等待简单任务的时间有很大差异。

1190
01:29:30,969 --> 01:29:34,860
现在，在我们讨论不同类型的搜索算法之前，我们必须辨别

1191
01:29:34,860 --> 01:29:40,430
数组或列表的两种状态，即排序或无序。

1192
01:29:40,430 --> 01:29:45,739
排序的信息列表以某种可排序的值为特征，无论是患者

1193
01:29:45,739 --> 01:29:52,370
ID、信用卡号，还是用户名或法定名称等字母值。无序列表

1194
01:29:52,370 --> 01:29:56,930
只是一些相关信息的随机组合，没有按任何

1195
01:29:56,930 --> 01:30:02,571
特定顺序或原因排序。有些搜索算法只适用于排序列表，通常

1196
01:30:02,571 --> 01:30:08,070
是效率更高的列表，而有些搜索算法则同时适用于排序列表和无序列表，尽管这些

1197
01:30:08,070 --> 01:30:11,841
列表通常效率较低。如果你最终进一步学习计算机科学，你将不得不

1198
01:30:11,841 --> 01:30:16,340
处理排序列表和无序列表，因此了解这两种列表的常见搜索实践

1199
01:30:16,340 --> 01:30:19,239
是有好处的。

1200
01:30:19,239 --> 01:30:23,111
还有一件需要注意的事情是，我们根据最坏情况和

1201
01:30:23,111 --> 01:30:29,160
必须搜索的平均项目数来确定搜索算法的效率。

1202
01:30:29,160 --> 01:30:33,910
我们称之为大 O 符号，其中每个搜索算法都有一个方程，

1203
01:30:33,910 --> 01:30:38,989
该方程将数组的大小作为整数 n，并将输出最坏情况的效率值，

1204
01:30:38,989 --> 01:30:44,469
我们可以使用该值与其他搜索算法进行比较。然后我们还可以查看

1205
01:30:44,469 --> 01:30:49,110
平均需要多长时间才能找到列表中的一个元素。使用这两种方法，

1206
01:30:49,110 --> 01:30:54,360
我们可以轻松比较两种算法的效率。好了，现在我们已经了解了一些搜索背景知识，

1207
01:30:54,360 --> 01:30:57,900
让我们直接开始吧。

1208
01:30:57,900 --> 01:31:01,480
我们将要讨论的第一种搜索类型称为线性搜索，您一生中可能

1209
01:31:01,480 --> 01:31:05,180
已经多次使用过这种搜索方式。每次您需要在人员列表中搜

1210
01:31:05,180 --> 01:31:09,160
索您的名字时，您可能都会遵循相同的模式。

1211
01:31:09,160 --> 01:31:14,180
您从顶部开始，检查列表中的第一个名字是否是您的，如果是的话。太好了。

1212
01:31:14,180 --> 01:31:18,300
如果没有，则转到列表中的下一个名称，直到找到您的名字，

1213
01:31:18,300 --> 01:31:23,430
或者没有找到，则退出。线性搜索的工作方式相同，

1214
01:31:23,430 --> 01:31:27,360
从列表中的第一个元素开始，将其与您要查找的值进行比较，

1215
01:31:27,360 --> 01:31:31,570
如果它们相同，则您找到了匹配项并返回该元素的索引，

1216
01:31:31,570 --> 01:31:35,610
如果不相同，则转到列表中的下一个元素，直到找到您要搜

1217
01:31:35,610 --> 01:31:40,360
索的内容或用尽列表进行检查。看起来很简单，对吧？

1218
01:31:40,360 --> 01:31:44,360
这是因为线性搜索在效率方面非常糟糕，尤其是

1219
01:31:44,360 --> 01:31:49,050
在最坏的情况下。如果您在列表中搜索的项目是最后一个元素，

1220
01:31:49,050 --> 01:31:53,320
则您必须检查整个项目列表才能找到您要搜索的项目。

1221
01:31:53,320 --> 01:31:57,260
但是，平均而言，您将在列表的一半左右找到它。

1222
01:31:57,260 --> 01:32:03,260
这使得线性搜索成为 O(n) 最坏情况，因为在最坏的情况下，

1223
01:32:03,260 --> 01:32:08,260
它将占用整个数组的长度或 n 来找到正确的值。线性搜索

1224
01:32:08,260 --> 01:32:15,280
平均将在 O(n/2) 或列表中间返回正确的索引。

1225
01:32:15,280 --> 01:32:19,640
线性搜索很棒；但是，由于它最终会覆盖列表中的每个元素，

1226
01:32:19,640 --> 01:32:25,100
因此它可以同时处理已排序和未排序的列表。

1227
01:32:25,100 --> 01:32:29,130
我们将介绍的另一种搜索要求列表已排序，这似乎是一个缺点，

1228
01:32:29,130 --> 01:32:33,210
但有了已排序的列表，您就可以使用比线性搜索更高效的算法。

1229
01:32:33,210 --> 01:32:37,631
因此，总的来说，如果您有一个未排序的列表，

1230
01:32:37,631 --> 01:32:42,040
线性搜索是一种很好的基本搜索算法，但如果您的列表已排序，

1231
01:32:42,040 --> 01:32:47,330
则有更高效的选项供您选择，例如我们现在要讨论的二分搜索。

1232
01:32:47,330 --> 01:32:51,890
二分查找使用递归过程将列表中的数据分解为更多

1233
01:32:51,890 --> 01:32:56,070
可管理的字节，利用其已排序的事实，以便

1234
01:32:56,070 --> 01:33:00,230
更快地找到所需的项目。这一点比较难理解，

1235
01:33:00,230 --> 01:33:06,880
所以我们先举个例子。假设您有一个按字母顺序排列的 10 个名字的列表，

1236
01:33:06,880 --> 01:33:11,930
就像现在屏幕上显示的一样，您想在该列表中找到您的名字。在二分搜索中，

1237
01:33:11,930 --> 01:33:17,270
您首先会查找最中间的名字，在本例中是第 4 个索引处的名字。

1238
01:33:17,270 --> 01:33:24,270
顺便说一句，由于没有“真正的”中间值，计算机会自动使用

1239
01:33:24,270 --> 01:33:29,910
下一个作为“中间”值。现在，一旦找到中间值，

1240
01:33:29,910 --> 01:33:36,190
首先检查您要搜索的名称是否位于您选择的索引中，如果是，

1241
01:33:36,190 --> 01:33:42,989
则只需返回该索引，但 99.9% 的时间它不包括在内，

1242
01:33:42,989 --> 01:33:48,521
所以让我们继续。如果中间索引处的值不等于您要搜索的值，

1243
01:33:48,521 --> 01:33:54,250
则检查您要搜索的值是在中间索引之前还是之后。

1244
01:33:54,250 --> 01:33:59,140
例如，如果您正在寻找名字 Brendan，而中间索引处的值为

1245
01:33:59,140 --> 01:34:05,920
Carl；Brendan显然按字母顺序排在 Matthew 之前，而且因为我们知道

1246
01:34:05,920 --> 01:34:10,980
列表是排序的，我们现在可以做的就是忽略列表的整个下半部分，

1247
01:34:10,980 --> 01:34:15,480
只关注顶部，因为我们知道如果 Brendan 甚至在列表中，它就会在上半部分。

1248
01:34:15,480 --> 01:34:21,190
现在，我们只需将列表的上半部分视为一个全新的实体

1249
01:34:21,190 --> 01:34:26,050
然后重复该过程。再次，我们会找到这个新名称列表的最中间

1250
01:34:26,050 --> 01:34:30,430
元素，并再次将其与您要查找的名称进行比较。如果它是我们要查找的名称，

1251
01:34:30,430 --> 01:34:34,760
我们将返回该索引，但如果不是，我们将

1252
01:34:34,760 --> 01:34:39,900
比较它是否位于中间索引之前或之后。回到我们的例子，假设这个新列表的

1253
01:34:39,900 --> 01:34:46,150
中间索引是 AJ。现在，我们知道 Brendan 在字母顺序上排在 AJ 之后，

1254
01:34:46,150 --> 01:34:52,390
所以我们现在可以忽略列表的上半部分，因为我们知道 Brendan

1255
01:34:52,390 --> 01:34:58,400
将位于列表的顶部。现在我们一次又一次地重复这个过程，直到找到

1256
01:34:58,400 --> 01:35:03,090
我们要找的名字。所以对于我们的例子来说，这次的中间索引是 Brendan，

1257
01:35:03,090 --> 01:35:09,510
这就是我们要搜索的，所以我们最终会返回索引 2 。在二分搜索中，

1258
01:35:09,510 --> 01:35:14,000
最终我们与搜索词进行比较的索引将是相同的，一旦相同，我们就可以返回

1259
01:35:14,000 --> 01:35:18,920
索引并继续。现在如果我们没有找到它，

1260
01:35:18,920 --> 01:35:23,460
这发生在我们排除了整个列表而没有找到我们的搜索词之后，

1261
01:35:23,460 --> 01:35:27,430
算法将简单地返回一个空值，让你知道你正在搜索的项目在列表中

1262
01:35:27,430 --> 01:35:33,180
找不到。二分搜索比线性搜索更快、更高效，

1263
01:35:33,180 --> 01:35:37,670
因为我们大大减少了我们必须查看的元素数量，从而使程序运行得更快。

1264
01:35:37,670 --> 01:35:44,190
在几乎 99.9% 的情况下，如果列表已排序，

1265
01:35:44,190 --> 01:35:49,430
二分查找会比线性查找更快地返回结果，因此，如果您有

1266
01:35:49,430 --> 01:35:55,620
一个已排序列表，最好的选择是使用二分查找。至于效率，

1267
01:35:55,620 --> 01:36:00,320
二分查找在最坏情况下的复杂度为 O(logn)，如果您不完全理解对数，

1268
01:36:00,320 --> 01:36:04,699
这可能会令人困惑，但您只需知道它比线性查找更有效率。

1269
01:36:04,699 --> 01:36:10,540
它的平均情况实际上也是 O(logn)，这比线性效率

1270
01:36:10,540 --> 01:36:12,840
高出无数倍。

1271
01:36:12,840 --> 01:36:17,670
现在，虽然您可以使用其他类型的搜索算法，但这两种算法对于无序和有序列表

1272
01:36:17,670 --> 01:36:23,300
都是最常见的，所以我们暂时就到此为止。接下来，

1273
01:36:23,300 --> 01:36:28,070
我们将介绍计算机科学中最令人困惑和最重要的主题之一，

1274
01:36:28,070 --> 01:36:29,610
递归。

1275
01:36:29,610 --> 01:36:36,750
让我们从最重要的问题开始：递归到底是什么意思？在编程中，

1276
01:36:36,750 --> 01:36:41,130
递归是指反复调用自身的函数。这意味着，在函数中

1277
01:36:41,130 --> 01:36:45,469
出现的指令中，其中一条指令将调用您已经使用的同一函数。

1278
01:36:45,469 --> 01:36:50,620
在屏幕上现在最基本的示例中，您可以看到我们有一些函数，

1279
01:36:50,620 --> 01:36:55,560
它在其自身范围内调用自身。递归函数通常会将

1280
01:36:55,560 --> 01:37:00,770
某个整数作为参数，并使用它来执行一些指令，

1281
01:37:00,770 --> 01:37:04,469
修改输入的整数，然后再次使用该新整数作为参数

1282
01:37:04,469 --> 01:37:05,840
调用自身。

1283
01:37:05,840 --> 01:37:10,090
为了更好地理解这些函数，让我们讨论一下如何编写这些递归函数并

1284
01:37:10,090 --> 01:37:12,890
自己创建一个递归函数的基础知识。一个非常好的简单递归函数示例是将

1285
01:37:12,890 --> 01:37:17,781
1 到 n 的所有数字相加，所以让我们创建一个可以完成此操作的递归函数。

1286
01:37:17,781 --> 01:37:21,930
我们需要的第一件事是实际函数，

1287
01:37:21,930 --> 01:37:26,750
我们将使它成为一个整数函数，以整数 n 作为参数。

1288
01:37:26,750 --> 01:37:31,440
我们这样做的原因将在后面解释，但现在让我们先讨论基本情况。

1289
01:37:31,440 --> 01:37:35,861
基本情况只是一个确定的值，所有递归语句（即在函数

1290
01:37:35,861 --> 01:37:40,410
执行过程中被反复调用的语句）都试图达到该值。在函数

1291
01:37:40,410 --> 01:37:44,030
开始时，我们会根据基本情况测试参数传入的值，以查看

1292
01:37:44,030 --> 01:37:48,570
是否满足该值。通常，这些基本情况是一些要求，例如，

1293
01:37:48,570 --> 01:37:53,440
如果 n（如我之前所述）达到某个值或等于某个值。

1294
01:37:53,440 --> 01:37:59,590
最终会满足的某些要求非常重要，

1295
01:37:59,590 --> 01:38:05,300
原因与避免无限循环一样重要：我们不希望发生堆栈溢出错误。

1296
01:38:05,300 --> 01:38:11,010
例如，如果我们的基准情况是在 n 大于 100 时停止调用递归函数，

1297
01:38:11,010 --> 01:38:16,320
如果不大于 100，我们再次调用该函数但使用 n-1，

1298
01:38:16,320 --> 01:38:22,390
并且我们从 n 开始为 99，那么我们将永远不会达到基准情况，

1299
01:38:22,390 --> 01:38:26,340
递归函数将一遍又一遍地重复调用自身，从 n 中减去 1，

1300
01:38:26,340 --> 01:38:32,160
并希望它最终会大于100，直到您的计算机崩溃，

1301
01:38:32,160 --> 01:38:38,380
这可不好玩。回到我们的递归求和示例，让我们在 

1302
01:38:38,380 --> 01:38:43,969
n 小于或等于 1 时确定基本情况。这样，我们可以从某个正整数 n 开始，

1303
01:38:43,969 --> 01:38:49,600
然后从中减去它，直到它达到或等于 1，在这种情况下，我们可以退出递归

1304
01:38:49,600 --> 01:38:56,940
语句。太棒了。现在，如果 n 不小于或等于 1，我们要做的是返回 

1305
01:38:56,940 --> 01:39:03,780
n 的总和，然后返回 recursiveSum 方法的返回值减 1。

1306
01:39:03,780 --> 01:39:09,400
为什么我们要添加 n + 函数调用？好吧，让我们像计算机一样

1307
01:39:09,400 --> 01:39:15,710
实际检查一下该函数，看看为什么。我们首先调用 n = 3 的 recursiveSum。

1308
01:39:15,710 --> 01:39:22,540
我们知道 3 不小于或等于 1，所以现在我们尝试返回 n（即 3）

1309
01:39:22,540 --> 01:39:27,040
的递归和以及 n 为 2 的 recursiveSum 的返回值。

1310
01:39:27,040 --> 01:39:32,960
我们不知道 n 为 2 的 recursiveSum 的返回值是什么，

1311
01:39:32,960 --> 01:39:40,100
所以我们必须再次执行该函数，只是这次 n 为 2。n 再次不小于或等于 1，

1312
01:39:40,100 --> 01:39:46,300
因此该函数将进入 else 语句并返回...2 加上另一个递归语句，

1313
01:39:46,300 --> 01:39:53,000
在本例中为 n 为 1 的 recursiveSum 的返回值。

1314
01:39:53,000 --> 01:39:57,420
因此，我们必须再次执行 recursiveSum 函数来获取将添加到 2 

1315
01:39:57,420 --> 01:40:04,400
然后返回的值，并将其添加到 3 然后返回。坚持住，我们快到了。

1316
01:40:04,400 --> 01:40:12,219
现在在这个函数中，n 小于或等于 1，所以我们返回 n，即 1。

1317
01:40:12,219 --> 01:40:18,660
现在我们取 n，也就是 1，这是在前一个函数调用中与 2 相加然后返回的结果，

1318
01:40:18,660 --> 01:40:25,390
所以这将返回 3。现在这个 3 被添加到第一个函数调用中，

1319
01:40:25,390 --> 01:40:33,160
也就是 3 ，因此它变成了 3 + 3，也就是 6。最后，

1320
01:40:33,160 --> 01:40:38,240
经过这么长时间，我们从函数中得到了 6。如果你一直在跟着做，

1321
01:40:38,240 --> 01:40:45,699
3 + 2 + 1 确实等于 6。现在这可能看起来像浪费时间，因为 1 + 2 +3

1322
01:40:45,699 --> 01:40:51,469
并不是一个困难的运算。但是对于那些说这个的，我请你们给我从

1323
01:40:51,469 --> 01:40:58,300
1 到 3567 所有数字的总和。天佑。递归是一个非常难以

1324
01:40:58,300 --> 01:41:03,130
理解的概念，所以如果你现在对它不是 100% 熟悉，

1325
01:41:03,130 --> 01:41:09,640
请重新观看这部分讲座，以便更好地熟悉它。

1326
01:41:09,640 --> 01:41:13,980
好酷，现在我们对递归有了一点了解，让我们来谈谈为什么它如此有效。

1327
01:41:13,980 --> 01:41:19,780
现在要理解递归的工作原理，我们必须首先了解什么是堆栈。

1328
01:41:19,780 --> 01:41:24,980
堆栈是一种数据结构，其中包含您指示程序完成的

1329
01:41:24,980 --> 01:41:29,710
所有任务。根据某种方法，您的程序将执行您赋予它的

1330
01:41:29,710 --> 01:41:30,710
任务。

1331
01:41:30,710 --> 01:41:35,810
之所以称为堆栈，是因为如果我们在前一个进程完成之前调用启动另一个进程，

1332
01:41:35,810 --> 01:41:40,310
则该进程会“堆叠”在另一个进程之上，就像屏幕上现在显示的

1333
01:41:40,310 --> 01:41:45,330
动画一样。我们编写的程序将遵循 LIFO 结构。

1334
01:41:45,330 --> 01:41:50,880
对于不熟悉会计的人来说，LIFO 意味着后进先出，或者最后一个

1335
01:41:50,880 --> 01:41:56,219
放入堆栈的项目将是第一个从堆栈中移除的项目。本质上，每次你要求

1336
01:41:56,219 --> 01:42:01,100
计算机完成一项任务时，该任务都会添加到堆栈中，并且将是第一个被解决的

1337
01:42:01,100 --> 01:42:06,010
任务。把它想象成一堆石头，你可以不断地在堆顶上加石头，

1338
01:42:06,010 --> 01:42:10,210
但是为了得到靠近底部的一块石头，你首先必须移除堆顶上的所有

1339
01:42:10,210 --> 01:42:14,781
石头。现在，当你的函数不断地无休止地调用自身时；没有基本

1340
01:42:14,781 --> 01:42:20,760
情况，就像在我们的无限循环示例中一样，堆栈将永远不会被解决，

1341
01:42:20,760 --> 01:42:25,620
因为项目将不断地添加到堆栈中，而任何一个都没有完成。

1342
01:42:25,620 --> 01:42:31,880
这种情况下，就会超出分配给堆栈的内存，发生堆栈溢出错误

1343
01:42:31,880 --> 01:42:38,000
导致你的程序崩溃。想象一下，你正在做家务，

1344
01:42:38,000 --> 01:42:42,160
在你完成一项家务之前，你就被叫去做另一项家务，然后

1345
01:42:42,160 --> 01:42:45,540
在你完成那项家务之前，你又被叫去做另一项家务。

1346
01:42:45,540 --> 01:42:51,010
由于您不断地将任务或家务堆叠在一起，这些任务永远

1347
01:42:51,010 --> 01:42:56,440
都无法完成，而且您可能会在完成任何家务之前死去。

1348
01:42:56,440 --> 01:43:00,810
这与导致无限循环导致程序崩溃的逻辑相同。递归也遵循同样的原理

1349
01:43:00,810 --> 01:43:05,570
初始调用会进行第二次调用，该调用会添加到堆栈中，

1350
01:43:05,570 --> 01:43:10,670
现在必须先处理该调用，但在此过程中

1351
01:43:10,670 --> 01:43:15,910
会调用另一个函数，该函数会添加到堆栈中，依此类推，直到到达基本情况，

1352
01:43:15,910 --> 01:43:19,080
在此情况下，您会慢慢开始返回堆栈。

1353
01:43:19,080 --> 01:43:24,840
总之，递归通常非常有用，因为通过反复调用相同的函数，

1354
01:43:24,840 --> 01:43:29,541
它可以将问题分解为更小的部分，

1355
01:43:29,541 --> 01:43:35,340
从而使程序更高效。与一次性解决整个问题相比，解决问题的小部分更容易解决，

1356
01:43:35,340 --> 01:43:40,199
计算量也更小，并且计算机最终可以将这些小解决方案

1357
01:43:40,199 --> 01:43:42,910
组合成主要解决方案。

1358
01:43:42,910 --> 01:43:47,000
现在，随着编程入门系列的结束，我们想花点时间回顾一下成

1359
01:43:47,000 --> 01:43:51,440
为一名成功的计算机科学家所需的一些软技能，因为这不仅仅

1360
01:43:51,440 --> 01:43:56,220
是编写代码。事实上，许多专业的计算机科学家会告诉你，

1361
01:43:56,220 --> 01:44:01,220
他们的大部分工作都是在思考代码，而不是实际编写代码。这是因

1362
01:44:01,220 --> 01:44:06,480
为编程的大部分工作归结为解决问题。我们如何优化这个系统

1363
01:44:06,480 --> 01:44:10,370
如何为我们的应用程序实现这个功能？我们想让我们的游戏实现什么类型的动作，

1364
01:44:10,370 --> 01:44:12,130
我们如何对其进行编程？

1365
01:44:12,130 --> 01:44:15,980
残酷的事实是，没有一个好的程序是简单地从程序员得到提示或想法，

1366
01:44:15,980 --> 01:44:21,199
坐下来，打开 IDE，然后开始编写代码。

1367
01:44:21,199 --> 01:44:25,940
为了规划我们的代码，我们需要事先完成许多任务，以确保在编程时，

1368
01:44:25,940 --> 01:44:30,390
这是一个干净、简单的过程，不会出现错误和漏洞。

1369
01:44:30,390 --> 01:44:35,199
这就是伪代码发挥作用的地方。

1370
01:44:35,199 --> 01:44:39,290
想象一下这样的伪代码，如果你想和家人一起去大峡谷旅行，

1371
01:44:39,290 --> 01:44:42,910
你会直接跳上车开走，然后再想办法吗？不会，

1372
01:44:42,910 --> 01:44:48,280
因为那样太荒谬了。相反，你会花一些时间规划行程，

1373
01:44:48,280 --> 01:44:52,200
你想参观哪些景点或地方？你要预订哪些酒店？

1374
01:44:52,200 --> 01:44:56,350
到达那里后你要做什么？你要走哪条路线或高速公路，

1375
01:44:56,350 --> 01:45:00,030
为什么？在你考虑跳上你的

1376
01:45:00,030 --> 01:45:04,330
福特探险者之前，必须先确定所有这些事情。那么这如何转化为伪代码呢？

1377
01:45:04,330 --> 01:45:10,250
好吧，把我们一家去大峡谷的旅行想象成一个程序。程序员使用伪代码，

1378
01:45:10,250 --> 01:45:15,280
伪意味着不是真实的，代码意味着，呃，代码，作为在编写程序

1379
01:45:15,280 --> 01:45:20,900
之前规划程序的一种手段，就像我们在出发前计划旅行一样。他们抛弃了

1380
01:45:20,900 --> 01:45:25,630
语法和变量的命名约定，只关注他们希望程序完成什么，

1381
01:45:25,630 --> 01:45:30,230
以及他们计划如何实现这些目标。伪代码与为您正在撰写的

1382
01:45:30,230 --> 01:45:34,600
论文构建大纲非常相似。您写下论文的主要主题并计划好

1383
01:45:34,600 --> 01:45:38,490
主要讨论要点，但不必担心所有细节，

1384
01:45:38,490 --> 01:45:43,760
例如词汇选择、语法约定和正确的格式。通过这样做，我们可以自由思考，

1385
01:45:43,760 --> 01:45:48,110
而不必担心强调小事。至少现在还不是。

1386
01:45:48,110 --> 01:45:53,750
好了，现在我们知道了什么是伪代码，让我们来讨论一下如何编写伪代码。

1387
01:45:53,750 --> 01:45:57,230
你看，伪代码最好的地方在于它可以为不同的人采用

1388
01:45:57,230 --> 01:46:01,470
不同的形式。每个计算机科学家可能都有自己的方法来

1389
01:46:01,470 --> 01:46:04,800
规划他们的代码，而且由于编写伪代码的方法

1390
01:46:04,800 --> 01:46:10,180
可能有数百种，今天我想重点介绍三种流行的方法，

1391
01:46:10,180 --> 01:46:13,320
我认为你可能会发现它们非常有用。

1392
01:46:13,320 --> 01:46:17,239
第一种被称为流程图，主要用来思考

1393
01:46:17,239 --> 01:46:22,719
某一特定功能的流程。流程图本质上是函数及

1394
01:46:22,719 --> 01:46:28,020
其流程的图形表示。许多程序员这样做，将他们想要的

1395
01:46:28,020 --> 01:46:32,010
条件语句和循环布置为流程图中的不同块，用箭头连接

1396
01:46:32,010 --> 01:46:36,750
并绘制出函数的每条路径。从这里开始，创建测试用例

1397
01:46:36,750 --> 01:46:40,440
并通过不同的块和箭头在整个函数流程中跟踪它们就变得

1398
01:46:40,440 --> 01:46:45,290
非常容易了。例如，我们可以有一个类似这样的流程图。

1399
01:46:45,290 --> 01:46:51,570
用户输入一个数字，如果这个数字是 8，我希望程序返回 True；但是，

1400
01:46:51,570 --> 01:46:56,710
如果这个数字不是 8，我希望返回 false。这是一种很好的方式来

1401
01:46:56,710 --> 01:47:00,710
直观地展示函数的总体用途，同时还可以查找您在思考函数时可能

1402
01:47:00,710 --> 01:47:06,080
遗漏的任何错误，例如缺少路径。它还将编程语句

1403
01:47:06,080 --> 01:47:11,290
抽象为简单的块，使其更容易修改或完全更改。最好

1404
01:47:11,290 --> 01:47:16,010
的部分是，当您完成测试用例后，您可以简单地将块转换为

1405
01:47:16,010 --> 01:47:21,540
语句，并且您有一个编写良好的函数而无需任何调试。

1406
01:47:21,540 --> 01:47:25,160
另一种经常使用的流行伪代码技术是简单地按时间顺序

1407
01:47:25,160 --> 01:47:29,720
写出您希望代码执行的操作。不一定非要考虑

1408
01:47:29,720 --> 01:47:34,250
要使用的语句和函数，只需从头到尾记下您正在编写的程序将要

1409
01:47:34,250 --> 01:47:39,440
执行的步骤。例如，假设您正在制

1410
01:47:39,440 --> 01:47:43,930
作一个应用程序，它接受两个数字并将它们相除。该应用程序的伪代码

1411
01:47:43,930 --> 01:47:48,550
看起来有点像这样。首先，我想提示用户输入一个数字，

1412
01:47:48,550 --> 01:47:54,070
然后等待用户输入第一个数字。在我得到第一个数字后，

1413
01:47:54,070 --> 01:47:59,030
我想再次提示用户输入第二个数字。一旦他们输入了第二个数字

1414
01:47:59,030 --> 01:48:04,691
我就通过将输入的两个数 字相除来完成操作并将结果返回给用户。

1415
01:48:04,691 --> 01:48:08,041
这一切似乎都是常识，但请记住，我们很多时候不会

1416
01:48:08,041 --> 01:48:14,560
使用简单的乘法函数我们可能会使用具有许多不同选项的全尺寸游戏、

1417
01:48:14,560 --> 01:48:20,160
算法或用户界面。这种方法可以让程序员

1418
01:48:20,160 --> 01:48:24,450
不被必须遵循的语法和惯例所困扰，您只需

1419
01:48:24,450 --> 01:48:28,590
记录程序的最终目标，就像向朋友解释一样。

1420
01:48:28,590 --> 01:48:32,699
这种方法确实可以让您规划出程序

1421
01:48:32,699 --> 01:48:37,550
中需要发生的一切，以便程序顺利运行。它还能确保你不会忘记

1422
01:48:37,550 --> 01:48:42,120
算法的某个部分，或者您需要随后写入的某个函数。

1423
01:48:42,120 --> 01:48:47,010
今天我想谈的最后一个伪代码策略是写出

1424
01:48:47,010 --> 01:48:51,370
你希望用户在使用你的程序时拥有的主要功能，以及你需要哪些函数

1425
01:48:51,370 --> 01:48:55,830
或小程序来完成这些功能。让我们再举一个例子，

1426
01:48:55,830 --> 01:49:00,880
假设你正在制作一个银行界面，在启动时，你希望用户

1427
01:49:00,880 --> 01:49:06,840
最初有 2 个不同的选项。他们可以设置一个新帐户或登录现有帐户。

1428
01:49:06,840 --> 01:49:10,320
从那里开始，如果他们登录他们的帐户，你希望他们能够

1429
01:49:10,320 --> 01:49:16,090
提取资金、存款、贷款或偿还贷款。

1430
01:49:16,090 --> 01:49:19,980
如果他们决定开设新帐户，你希望他们能够创建一个帐户，将他们的信

1431
01:49:19,980 --> 01:49:24,070
息存储在数据库中，然后访问回访会员可以拥有的所有功能。

1432
01:49:24,070 --> 01:49:29,910
这可能看起来与流程图非常相似，唯一的区别是，

1433
01:49:29,910 --> 01:49:35,699
这是对整个程序而不是单个函数的更高级别的抽象。

1434
01:49:35,699 --> 01:49:40,050
如果您真的想这样做，您还可以创建一个流程图，

1435
01:49:40,050 --> 01:49:45,010
以介绍上述所有 4 种方法的功能。设置屏幕上显示的层次结构

1436
01:49:45,010 --> 01:49:50,050
可以清楚地看到您必须制作的每个功能和界面。

1437
01:49:50,050 --> 01:49:54,260
这可以防止您在最后一秒尝试将某个功能或特性强行塞

1438
01:49:54,260 --> 01:49:59,090
入几乎完成的程序中，而这根本不是一个有趣的体验。

1439
01:49:59,090 --> 01:50:04,240
以上就是 3 种伪代码策略，您可以在开始编写代码之前

1440
01:50:04,240 --> 01:50:08,699
使用这些策略规划代码。流程图方法适合思考某个函数的流程。

1441
01:50:08,699 --> 01:50:12,949
编写方法适合了解程序的总体思路，

1442
01:50:12,949 --> 01:50:17,840
功能规划方法适合列出某个程序的功能。

1443
01:50:17,840 --> 01:50:22,929
您可以不使用其中任何一种，也可以全部使用，或者混合使用其中几种，

1444
01:50:22,929 --> 01:50:28,590
甚至可以忽略这些，寻找或创建自己的方法。这里的主要目标是大幅减少

1445
01:50:28,590 --> 01:50:32,469
编程过程中出现的错误数量，减轻您的压力。

1446
01:50:32,469 --> 01:50:37,120
伪代码的重要性怎么强调也不为过，如果你不相信

1447
01:50:37,120 --> 01:50:42,310
我，我建议你尝试在不使用伪代码的情况下完成一个大型项目。

1448
01:50:42,310 --> 01:50:46,410
好的，如果您已经观看了本系列节目，那么您已经对编程

1449
01:50:46,410 --> 01:50:51,390
的许多方面以及如何规划程序有了很好的了解。现在

1450
01:50:51,390 --> 01:50:56,010
是时候进入现实世界并编写一些实际代码了。

1451
01:50:56,010 --> 01:51:01,530
但是，要编写什么样的程序呢？我能听到你在问我。答案是，

1452
01:51:01,530 --> 01:51:05,370
真的，你想写什么就写什么。我相信你现在已经知道，你可以编

1453
01:51:05,370 --> 01:51:10,530
写任何你想编写的东西，从简单的游戏到复杂的软件。我们为

1454
01:51:10,530 --> 01:51:15,370
你提供了你决定编写的几乎任何程序中都会用到的基础知识。但

1455
01:51:15,370 --> 01:51:20,360
这并不意味着每种编程语言都适合每个应用程序。每种语言都

1456
01:51:20,360 --> 01:51:25,050
有自己的优点和缺点，选择正确的语言非常重要，这样可以让你

1457
01:51:25,050 --> 01:51:30,321
更轻松地（有时甚至可能）编写你想要的程序。所以，这就是

1458
01:51:30,321 --> 01:51:34,739
我们现在要讨论的内容：选择最适合你想要完成的任务的语言。

1459
01:51:34,739 --> 01:51:40,679
现在，我们之前讨论了低级编程语言与高级编程语言。如果您忘记了，

1460
01:51:40,679 --> 01:51:45,239
让我们快速复习一下。高级编程语言对机器语言

1461
01:51:45,239 --> 01:51:49,989
（即很久以前的 0 和 1 序列）具有较高的抽象程度，

1462
01:51:49,989 --> 01:51:55,370
而低级编程语言对机器语言具有较低的抽象。

1463
01:51:55,370 --> 01:52:00,070
程度。例如，像 2d 乐高积木一样将编程语句拖放在一起的块

1464
01:52:00,070 --> 01:52:05,590
编程是一种高级语言，因为编程不需要对计算机内部

1465
01:52:05,590 --> 01:52:11,130
工作原理有很高的理解。理论上，编程语言的最高级别是，

1466
01:52:11,130 --> 01:52:15,570
如果我能用简单的英语写下我想让计算机做的事情，

1467
01:52:15,570 --> 01:52:21,800
它就能工作。但遗憾的是，这还不存在。另一方面，

1468
01:52:21,800 --> 01:52:26,469
最低级的编程语言只是以超音速将 0 和 1

1469
01:52:26,469 --> 01:52:32,020
输入计算机，这几乎是不可能的，也是极其荒谬的。

1470
01:52:32,020 --> 01:52:37,530
那么，您如何选择最适合您需求的语言类型呢？这取决于

1471
01:52:37,530 --> 01:52:41,840
您要做什么，因为有时您需要非常专业的语言才能完成您想要的

1472
01:52:41,840 --> 01:52:47,430
工作。计算机科学的世界非常广阔，包含许多领域，因此试图

1473
01:52:47,430 --> 01:52:51,810
用一种语言涵盖所有内容是不可能的。这导致了数千种不同的

1474
01:52:51,810 --> 01:52:56,860
编程语言的诞生，每种语言都是为特定任务而设计的。不过现在，

1475
01:52:56,860 --> 01:53:01,210
我们将介绍一些最流行的语言及其用途。现在，

1476
01:53:01,210 --> 01:53:05,040
如果你想设计一个网站，并深入研究这条职业道路，使用 HTML 

1477
01:53:05,040 --> 01:53:10,640
和 CSS 可能是你最好的选择。HTML 是一种标记语言，用于编写

1478
01:53:10,640 --> 01:53:16,160
网站的内容，而 CSS 非常适合设计网站的风格。你

1479
01:53:16,160 --> 01:53:20,590
每天都会与 HTML代码互动，如果你右键单击并点击检查元素，

1480
01:53:20,590 --> 01:53:26,510
你现在甚至可以看到它，这将真正向你展示 HTML 和 CSS 有多么复杂。

1481
01:53:26,510 --> 01:53:30,910
也许使用脚本语言对你来说是最好的选择。脚本语言是一种有

1482
01:53:30,910 --> 01:53:34,610
许多命令可供你使用且无需编译即可运行的

1483
01:53:34,610 --> 01:53:39,870
语言。编写脚本的速度比实际程序更快，并且往往更容易在操作

1484
01:53:39,870 --> 01:53:45,640
系统之间移植，从而实现跨平台支持。脚本还可以

1485
01:53:45,640 --> 01:53:51,340
用于网站，通常会增加网站的整体用户体验。如果你想

1486
01:53:51,340 --> 01:53:55,650
从事网页设计，这也可能是一条适合你的道路。脚本语言

1487
01:53:55,650 --> 01:53:58,370
的例子有 Perl、PHP、Ajax 和 Javascript。

1488
01:53:58,370 --> 01:54:03,390
如果你只是想编写通用程序，那么你应该使用通

1489
01:54:03,390 --> 01:54:11,070
用语言。通用语言，顾名思义，应用范围很广。

1490
01:54:11,070 --> 01:54:16,210
通常这些应该是您的首选语言。通用语言的例子有

1491
01:54:16,210 --> 01:54:22,421
Java、C++ 和 Python。它们各有各的优势。Java 

1492
01:54:22,421 --> 01:54:28,300
最擅长开发游戏和交互式网页，Python 可以作为脚本语言

1493
01:54:28,300 --> 01:54:34,170
用于网页编程以及编写应用程序和数据分析。而 C++ 最适合

1494
01:54:34,170 --> 01:54:39,260
编写应用程序和系统程序。它们都有各种包，

1495
01:54:39,260 --> 01:54:43,410
您可以导入并使用它们来实现所需的功能。虽然为您

1496
01:54:43,410 --> 01:54:47,440
的大型项目选择合适的通用语言非常重要，但对于

1497
01:54:47,440 --> 01:54:52,160
大多数程序来说，任何一种语言都可以使用。这真的取决于偏好。

1498
01:54:52,160 --> 01:54:57,130
了解每种语言，并决定您最喜欢和最舒服的语法规则。

1499
01:54:57,130 --> 01:55:01,410
如果您非常了解一种通用语言并喜欢用它编程，那么您可以

1500
01:55:01,410 --> 01:55:05,460
将它应用于您计划编写的任何程序。就我个人而言，

1501
01:55:05,460 --> 01:55:09,739
我倾向于在大多数项目中使用 Python。这主要不是因为 Python 和

1502
01:55:09,739 --> 01:55:14,460
任何其他通用语言之间存在任何功能差异，尽管它们之间有很多差异

1503
01:55:14,460 --> 01:55:18,510
但主要是因为我发现它的语法规则最方便，最容易

1504
01:55:18,510 --> 01:55:23,950
编写程序。总的来说，您可以考虑您计划做的项目，然后研究

1505
01:55:23,950 --> 01:55:29,469
哪种语言最有利于您的目的，或者您可以

1506
01:55:29,469 --> 01:55:34,580
熟悉一种语言并将其用于您决定编写的大多数项目。

1507
01:55:34,580 --> 01:55:40,250
我们现在来讨论这个编程入门小系列的最后一个主题。

1508
01:55:40,250 --> 01:55:44,449
现在，您已经掌握了编程基础知识，这些知识将帮助您在学习任何语言时

1509
01:55:44,449 --> 01:55:49,260
取得长足进步，您还了解了一些很好的预编程伪代码策略，可以

1510
01:55:49,260 --> 01:55:53,820
帮助您从头开始设计代码，并且您可能已经对要开始学习的编程语言

1511
01:55:53,820 --> 01:55:57,880
类型有了很好的想法，那么下一步是什么呢？我如何学习该语言以及

1512
01:55:57,880 --> 01:56:02,320
它可以用于哪些应用程序？好吧，这就是我们

1513
01:56:02,320 --> 01:56:05,520
现在要介绍的内容，所以让我们直接进入吧。

1514
01:56:05,520 --> 01:56:09,420
从最大的问题开始，即下一步是什么。好吧

1515
01:56:09,420 --> 01:56:13,760
既然您可能知道您可能对哪种语言感兴趣，

1516
01:56:13,760 --> 01:56:18,410
请研究该语言并找出您是否真正想要追求该编程语言。

1517
01:56:18,410 --> 01:56:24,590
大多数语言（如python或C++）都会有一个官方网站供您阅读，

1518
01:56:24,590 --> 01:56:28,850
或者有一个维基百科页面，可为您提供有用的信息，以决定是否要走这条路。

1519
01:56:28,850 --> 01:56:33,750
从那里开始，下一步就是真正学习该语言，

1520
01:56:33,750 --> 01:56:38,770
这可以在YouTube上完成。虽然我们已经教过您任何编程语言的基础知识，

1521
01:56:38,770 --> 01:56:43,010
但每种特定语言都会扩展基本概念，因此观看特定语言的

1522
01:56:43,010 --> 01:56:46,000
教程视频将非常有益。许多网站会试图

1523
01:56:46,000 --> 01:56:47,000
让您购买付费课程或参加需要付费的课程，

1524
01:56:47,000 --> 01:56:48,000
但您可以在YouTube上找到非常好而且绝对不需要花费任何费用的课程

1525
01:56:48,000 --> 01:56:51,320
我会从您目前正在观看的介绍系列开始，但针对您选择的语言，

1526
01:56:51,320 --> 01:56:55,580
然后逐步完成该系列，掌握该语言的

1527
01:56:55,580 --> 01:56:59,920
语法和规则，直到您熟悉它为止。

1528
01:56:59,920 --> 01:57:04,060
一旦你这样做了，你就会来到一个十字路口。你知道如何用某种语言编程，

1529
01:57:04,060 --> 01:57:08,891
但你可能完全不知道用这种语言可以做什么。编程瓶颈

1530
01:57:08,891 --> 01:57:13,620
会让你失去灵感，不想继续编程，所以我想给你

1531
01:57:13,620 --> 01:57:15,719
一些网站来帮助你。

1532
01:57:15,719 --> 01:57:20,219
首先是 codingbat，这是一个完全免费的网站，它有数百个

1533
01:57:20,219 --> 01:57:26,170
Java 和 Python 编程挑战，可以帮助你提高编程技能，甚至学习一些编程捷径和技巧。

1534
01:57:26,170 --> 01:57:31,420
如果你想提高效率，需要一些东西来磨练你作为开发人员的技能，

1535
01:57:31,420 --> 01:57:37,340
那么这是一个很好的选择。接下来是 CoderByte，它提供了 200 多个

1536
01:57:37,340 --> 01:57:41,400
挑战，你可以用 10 多种不同的语言完成，这肯定有助于你提高水平。

1537
01:57:41,400 --> 01:57:46,110
最后一个我想谈的网站是 hackerRank，它不

1538
01:57:46,110 --> 01:57:50,630
仅提供编程挑战让你保持警惕，还支持你利用

1539
01:57:50,630 --> 01:57:53,550
编程技能寻找工作或实习机会，如果你正在

1540
01:57:53,550 --> 01:57:55,080
学习编程技能，你肯定已经考虑过这一点。这些网站和

1541
01:57:55,080 --> 01:57:59,660
许多其他网站的存在只是为了让你对代码保持兴趣，并努力提高你的技能，

1542
01:57:59,660 --> 01:58:00,850
让你变得更好，你只需要找到它们，因为它们肯定存在。

1543
01:58:00,850 --> 01:58:04,989
现在，如果你是一名正在观看本系列的青少年，我也鼓励你在高中时参加

1544
01:58:04,989 --> 01:58:10,270
编程课程。AP 计算机科学原理和 AP 计算机科学 A

1545
01:58:10,270 --> 01:58:15,340
都是很棒的课程，它们将在未来对你大有帮助，

1546
01:58:15,340 --> 01:58:20,340
而且对大学来说也非常有用和重要。你的学校可能还会提供计算机科学领域的其他课程，

1547
01:58:20,340 --> 01:58:25,910
包括数据结构、游戏设计和数据科学课程。你可以参加的任何课程都

1548
01:58:25,910 --> 01:58:30,140
有助于扩展你的编程知识并帮助你找到自己的位置，

1549
01:58:30,140 --> 01:58:33,370
这将大有帮助。

1550
01:58:33,370 --> 01:58:37,270
如您所见，代码世界现已向您敞开。这些只是您可以从

1551
01:58:37,270 --> 01:58:41,410
这里前往的几个示例，但还有更多我们没有讨论的内容。

1552
01:58:41,410 --> 01:58:45,920
您可以进入 GitHub并开始为项目做出贡献，您可以从事自己的项目并与他人合作，

1553
01:58:45,920 --> 01:58:51,239
可能性无穷无尽。下一步由您决定。

1554
01:58:51,239 --> 01:58:55,660
这就是我们关于编程的介绍系列的结束，我们希望您喜欢观看它，

1555
01:58:55,660 --> 01:59:00,679
就像我们喜欢制作它一样。如果您喜欢整个系列，

1556
01:59:05,080 --> 01:59:08,630
请考虑订阅我们的频道NullPointerException，该频道将在描述中链接，

1557
01:59:05,080 --> 01:59:08,630
以获取即将推出的更多内容。感谢您的收看。

