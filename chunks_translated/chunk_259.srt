1253
01:34:39,900 --> 01:34:46,150
这个新列表的中间索引是 AJ。现在，我们知道 Brendan

1254
01:34:46,150 --> 01:34:52,390
在字母顺序上排在 AJ

1255
01:34:52,390 --> 01:34:58,400
之后，所以我们现在可以忽略列表的上半部分，因为我们知道

1256
01:34:58,400 --> 01:35:03,090
Brendan

1257
01:35:03,090 --> 01:35:09,510
将位于列表的顶部。现在我们一次又一次地重复这个过程，直到找

1258
01:35:09,510 --> 01:35:14,000
到我们要找的名字。所以对于我们的例子来说，这次的中间索引是

1259
01:35:14,000 --> 01:35:18,920
Brendan，这就是我们要搜索的，所以我们最终会返回索引

1260
01:35:18,920 --> 01:35:23,460
2。在二分搜索中，最终我们与搜索词进行比较的索引将是相同的，一旦相同，我们就可以返回

1261
01:35:23,460 --> 01:35:27,430
索引并继续。现在如果我们没有找到它，这发生在我们排除了整个列表而没有找到我们的搜索词

1262
01:35:27,430 --> 01:35:33,180
之后，算法将简单地返回一个空值，让你知道你正在搜索的项目在列表中找不到。二分搜索比线

1263
01:35:33,180 --> 01:35:37,670
性搜索更快、更高效，因为我们大大减少了我们必须查看的元素数量，从而使程序运行得更快。

1264
01:35:37,670 --> 01:35:44,190
在几乎 99.9%

1265
01:35:44,190 --> 01:35:49,430
的情况下，如果列表已排序，二分查找会比线性查找更快地返回结果，因此，如果您有一

1266
01:35:49,430 --> 01:35:55,620
个已排序列表，最好的选择是使用二分查找。至于效率，二分查找在最坏情况下的复杂度为

1267
01:35:55,620 --> 01:36:00,320
O(log

1268
01:36:00,320 --> 01:36:04,699
n)，如果您不完全理解对数，这可能会令人困惑，但您只需知道它比线性查找更有效率。

