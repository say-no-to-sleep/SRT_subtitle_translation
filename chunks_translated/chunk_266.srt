1294
01:37:53,440 --> 01:37:59,590
最终会满足的某些要求非常重要，原因与避免无限循环一样重要：我们不希望发生堆栈溢出错误。例如，如果我们的基准情况是在

1295
01:37:59,590 --> 01:38:05,300
n 大于 100 时停止调用递归函数，如果不大于

1296
01:38:05,300 --> 01:38:11,010
100，我们再次调用该函数但使用 n-1，并且我们从 n 开始为

1297
01:38:11,010 --> 01:38:16,320
99，那么我们将永远不会达到基准情况，递归函数将一遍又一遍地重复调用自身，

1298
01:38:16,320 --> 01:38:22,390
从 n 中减去 1，并希望它最终会大于

1299
01:38:22,390 --> 01:38:26,340
100，直到您的计算机崩溃，这可不好玩。所以无论如何回到我们的递归求和示例，

1300
01:38:26,340 --> 01:38:32,160
时设置基准情况。这样，我们可以从某个正整数 n

1301
01:38:32,160 --> 01:38:38,380
1，在这种情况下我们可以退出递归语句。太棒了。现在，

1302
01:38:38,380 --> 01:38:43,969
如果 n 不小于或等于 1，我们想要做的是返回 n

1303
01:38:43,969 --> 01:38:49,600
的总和，然后返回 recursiveSum 方法的返回值减

1304
01:38:49,600 --> 01:38:56,940
函数调用？好吧，让我们像计算机一样实际地看一下这个函数，看看为什么。

1305
01:38:56,940 --> 01:39:03,780
我们从 n = 3 的 recursiveSum 调用开始。我们知道 3

1306
01:39:03,780 --> 01:39:09,400
不小于或等于 1，所以现在我们尝试返回 n（即

1307
01:39:09,400 --> 01:39:15,710
3）的递归总和以及 n 为 2 的 recursiveSum 的返回值。

1308
01:39:15,710 --> 01:39:22,540
将基准情况设置为 n 让我们在 n 小于或等于 1

1309
01:39:22,540 --> 01:39:27,040
1。为什么我们要加上 n + 开始并从中减去，直到它达到或等于

